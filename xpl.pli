/* %PROCESS RUNOPS('INTERRUPT(ON)'); DOESN'T WORK ON OS/2*/

/******************************************************************************/
/* THIS IS THE OPTIMIZING VERSION OF THE XPL COMPILER,                        */
/* PREPARED BY R. A. VOWELS                                                   */
/*                                                                            */                                               */
/* VisualAge PL/I version.  3rd April 2001.                                   */
/* This compiler has been compiled successfully on IBM PL/I for OS/2.         */
/* For linking under OS/2, use the command:                                   */
/*    LINK386 objectfile /STACK:6000000 /CO;                                  */
/* To execute under OS/2, you will need the following commands:               */
/*    SET DD:LIBRARY=LIBRARY.DAT,TYPE(TEXT),RECSIZE(80)                       */
/*    SET DD:BINARYFILE=BINARYFI.OUT,TYPE(FIXED),RECSIZE(3600)                */
/*    SET DD:SYSIN=STDIN:                                                     */
/*    SET DD:SYSPRINT=STDOUT:                                                 */
/*                                                                            */
/* To execute under Windows, you willl need the following commands:           */
/*    SET DD:LIBRARY=LIBRARY.DAT,TYPE(CRLF),RECSIZE(80)                       */
/*    SET DD:BINARYFILE=BINARY.OUT,TYPE(FIXED),RECSIZE(3600)                  */
/*    SET DD:SYSIN=XPL.DAT,TYPE(CRLF),RECSIZE(80)                             */
/*      (You can change XPL.DAT to any name that you want)                    */

/* Sample source */
/*
DECLARE (A, B, C) FIXED;

A = 5;
B = A+7;
C = A*B;
OUTPUT = B;

EOF EOF EOF EOF EOF
*/

/* When this source code is compiled and linked, the executable code (the EXE */
/* file) is ready-to-run.  It does not need the XPL monitor (XMON) to run it. */
/* However, the binary file produced by executing a program that has been     */
/* compiled by the EXE file, requires XMON in order to run.                   */
/*                                                                            */
/* Warning:                                                                   */
/* This version has been compiled and executed successfully, using the        */
/* XPL compiler as source.  The compiled code (System 390 machine code)       */
/* has NOT been run on an IBM System 390.                                     */
/* The compiler is still under test.  If anyone cares to run it on a System   */
/* 390, would you kindly let me know how it goes.  Thankyou                   */
/* Corrections:                                                               */
/* 25 March 2009 Last line of CATENATE_CODE: second argument was "FF"B4,      */
/*               changed to "F"B4                                             */

/******************************************************************************/

                                                                              /*
 X          X          CCCCC               OOOOO            M         M
  X        X          C     C             O     O           MM       MM
   X      X          C       C           O       O          M M     M M
    X    X          C         C         O         O         M  M   M  M
     X  X           C                   O         O         M   M M   M
      XX            C                   O         O         M    M    M
      XX            C                   O         O         M         M
     X  X           C                   O         O         M         M
    X    X          C         C         O         O         M         M
   X      X          C       C           O       O          M         M
  X        X          C     C             O     O           M         M
 X          X          CCCCC               OOOOO            M         M


                       THE COMPILER FOR   X P L


W. M. MCKEEMAN         J. J. HORNING           D. B. WORTMAN

INFORMATION &          COMPUTER SCIENCE        COMPUTER SCIENCE
COMPUTER SCIENCE,      DEPARTMENT,             DEPARTMENT,

UNIVERSITY OF          STANFORD                STANFORD
CALIFORNIA AT          UNIVERSITY,             UNIVERSITY,

SANTA CRUZ,            STANFORD,               STANFORD,
CALIFORNIA             CALIFORNIA              CALIFORNIA
95060                  94305                   94305

DEVELOPED AT THE STANFORD COMPUTATION CENTER, CAMPUS FACILITY,   1966-69
AND THE UNIVERSITY OF CALIFORNIA COMPUTATION CENTER, SANTA CRUZ, 1968-69.

The Optimizing version of XPL was developed by:

R. A. Vowels, formerly of
Department of Computer Science
Royal Melbourne Institute of Technology,
124 La Trobe Street,
MELBOURNE 3000
Victoria
AUSTRALIA.

email address is now: robin_v@bigpond.com

Outline:
        This optimizing XCOM compiler is a standard implementation of XPL and is
        based on McKeeman, Horning, and Wortman's improved XCOM (which employs
        hashed symbol table generation).  It includes the extra built-in
        function COREHALFWORD.

        The following areas have been optimized:  procedure calls when the
        argument and corresponding parameter are of the same type, and when the
        argument is a constant; constant subscripts; use of CORELHALFWORD and
        COREWORD; string constants of length one; iterative DO statements by
        transferring code to the end of the loop.

        String constants of length one do not require a descriptor, hence more
        descriptors are available for string variables.  Comparison operations
        are treated as commutative, and an improved Commute algorithm is used.
        Halfword instructions are generated for BIT(16) variables.

        These areas have been improved or re-written:  calls on OUTPUT,
        catenation, integer-to-string conversion, multiply, divide, and MOD.  An
        emitter for SS-type instructions has been added.

        The compiler achieves an 11% reduction in object code compiling itself,
        an 11% increase in compilation rate, a 55% increase in compilation speed
        when the $ E toggle is set.  Special treatment for catenating a string to
        an integer substantially decreases consumption of the free string area,
        and decreases string moves.  The latter improvement is most noticeable
        on small core machines.

        Core requirements:  less than the improved XCOM on which it is based
        (approx.  98000 bytes).  Symbol table size is 468.

ports:        IBM System 370
portability:  The compiler is written in XPL.  The code generators are
              machine-specific.

This version distributed by Robin Vowels.  Date: 11 November 1993.
                                                 11 December 1998.
     Initial description improved;
     Windows information added                   23 March 2009.
*/

(SUBSCRIPTRANGE, STRINGRANGE, STRINGSIZE, FIXEDOVERFLOW, SIZE):
XPL_COMPILER:
   PROCEDURE OPTIONS (MAIN, REORDER);

/*   DECLARE SYSPRINT FILE; */
   DECLARE LIBRARY FILE INPUT;
/*   DECLARE (CODEFILE, DATAFILE) FILE; */
   DECLARE Dummy FIXED BINARY (15);
   DECLARE OP1 BIT(8) ALIGNED, (REG1, REG2) UNSIGNED FIXED BINARY(8);

   DECLARE (TIME_OF_GENERATION, DATE_OF_GENERATION) FIXED BINARY (31);
   TIME_OF_GENERATION = XPL_TIME();
   DATE_OF_GENERATION = XPL_DATE();

   DECLARE (FREEBASE, FREELIMIT) FIXED BINARY (31);

   ON ATTENTION SNAP BEGIN;
      DECLARE Ch CHARACTER(1);

      PUT SKIP LIST ('Attention interrupt.  Continue? (0/1)');
      GET EDIT (Ch) (A(1));
      IF Ch = '1' THEN STOP;
   END;

   DECLARE TRACEBACK CONDITION;
   ON CONDITION (TRACEBACK) SNAP ;
 
   ON CONVERSION SNAP BEGIN;
      DECLARE Error_Count FIXED BINARY(7) STATIC INITIAL (0);
      DECLARE (ONCHAR, ONSOURCE) BUILTIN;

      Error_count = Error_count + 1;
      IF Error_count > 10 THEN
         DO;
            ONSOURCE = '0';
            IF Error_Count > 20 THEN STOP;
         END;
      ONCHAR = '0';
   END;

   ON STRINGRANGE SNAP BEGIN;
      PUT SKIP EDIT('CP=', CP, ' TEXT=', TEXT, '|')(A, F(11), 3 A);
      PUT SKIP EDIT ('LENGTH(TEXT)=', LENGTH(TEXT))(A, F(11));
   END;

TRACE:
   PROCEDURE;
   END;
UNTRACE:
   PROCEDURE;
   END;

   /*  FIRST WE INITIALIZE THE GLOBAL CONSTANTS THAT DEPEND UPON THE INPUT
      GRAMMAR.  THE FOLLOWING CARDS ARE PUNCHED BY THE SYNTAX PRE-PROCESSOR  */

   DECLARE NSY FIXED BINARY(7) VALUE (91), NT FIXED BINARY(7) VALUE (42);
   DECLARE V(0:NSY) CHARACTER (26) STATIC VARYING INITIAL (
      '<ERROR: TOKEN = 0>', ';', ')', '(', ',',
      ':', '=', '|', '&', '^', '<', '>', '+', '-', '*', '/', 'IF', 'DO', 'TO',
      'BY', 'GO', '||', '_|_', 'END', 'BIT', 'MOD', 'THEN', 'ELSE', 'CASE',
      'CALL', 'GOTO', 'WHILE', 'FIXED', 'LABEL', 'RETURN', 'DECLARE', 'INITIAL',
      '<STRING>', '<NUMBER>', 'PROCEDURE', 'LITERALLY', 'CHARACTER',
      '<IDENTIFIER>', '<TYPE>', '<TERM>', '<GROUP>', '<GO TO>', '<ENDING>',
      '<PROGRAM>', '<REPLACE>', '<PRIMARY>', '<VARIABLE>', '<BIT HEAD>',
      '<CONSTANT>', '<RELATION>', '<STATEMENT>', '<IF CLAUSE>', '<TRUE PART>',
      '<LEFT PART>', '<ASSIGNMENT>', '<EXPRESSION>', '<GROUP HEAD>',
      '<BOUND HEAD>', '<IF STATEMENT>', '<WHILE CLAUSE>', '<INITIAL LIST>',
      '<INITIAL HEAD>', '<CASE SELECTOR>', '<STATEMENT LIST>',
      '<CALL STATEMENT>', '<PROCEDURE HEAD>', '<PROCEDURE NAME>',
      '<PARAMETER LIST>', '<PARAMETER HEAD>', '<LOGICAL FACTOR>',
      '<SUBSCRIPT HEAD>', '<BASIC STATEMENT>', '<GO TO STATEMENT>',
      '<STEP DEFINITION>', '<IDENTIFIER LIST>', '<LOGICAL PRIMARY>',
      '<RETURN STATEMENT>', '<LABEL DEFINITION>', '<TYPE DECLARATION>',
      '<ITERATION CONTROL>', '<LOGICAL SECONDARY>', '<STRING EXPRESSION>',
      '<DECLARATION ELEMENT>', '<PROCEDURE DEFINITION>',
      '<DECLARATION STATEMENT>', '<ARITHMETIC EXPRESSION>',
      '<IDENTIFIER SPECIFICATION>');
   DECLARE V_INDEX(0:12) FIXED BINARY(7) STATIC INITIAL (
      1,16,22,26,31,34,35,37,39,42, 42, 42, 43);
   DECLARE C1(0:NSY) BIT(86) STATIC ALIGNED INITIAL (
/*      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 02000 00000 00000 02200 20220 00202 20002 20000 002",
      "(2) 02222 02222 22222 20022 02003 22000 00330 02000 030",
      "(2) 00030 00003 00330 00000 00000 00000 00000 00330 003",
      "(2) 00030 00002 00220 00000 00000 00000 00000 00220 003",
      "(2) 02000 00000 00000 02200 20020 00002 20002 20002 002",
      "(2) 00020 00002 00220 00000 00000 00000 00000 00220 002",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 00010 01000 11110 00000 00000 00000 00000 00110 001",
      "(2) 00020 01000 00220 00000 00000 00000 00000 00220 002",
      "(2) 00020 01000 00220 00000 00000 00000 00000 00220 002",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00110 001",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00110 001",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00110 001",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00110 001",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 01000 00000 00000 00000 00000 00010 01000 00000 001",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 003",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 00000 00000 00000 00010 00000 00000 00000 00000 000",
      "(2) 00010 00000 00110 00000 00000 00000 00000 00110 001",
      "(2) 01000 00000 00000 01100 10000 00001 10001 10000 001",
      "(2) 02000 00000 00000 00000 00000 00000 00000 00000 001",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00110 001",
      "(2) 02000 00000 00000 02200 20000 00002 20002 20000 002",
      "(2) 02000 00000 00000 02200 20000 00002 20002 20000 002",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 001",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 002",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 02002 00000 00000 00000 00000 00000 00000 02000 000",
      "(2) 02002 00000 00000 00000 00000 00000 00000 02000 000",
      "(2) 02010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00000 001",
      "(2) 00010 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 02202 02222 22222 20022 02000 22000 00000 00000 000",
      "(2) 02302 02222 22222 20022 02000 22000 00000 00000 000",
      "(2) 02020 00000 00000 00000 00002 00000 00220 00000 020",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00100 000",
      "(2) 02002 00000 00000 00000 00000 00000 00000 02000 000",
      "(2) 02333 12222 22222 20022 02002 22000 00220 00000 120",
      "(2) 03002 00000 00000 00000 00000 00000 00000 02000 000",
      "(2) 02202 02222 22221 10022 02000 12000 00000 00000 000",
      "(2) 01000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 001",
      "(2) 02000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 02202 02222 22222 20022 02000 22000 00000 00000 000",
      "(2) 02203 03222 22222 20022 02000 22000 00000 00000 000",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00010 000",
      "(2) 02303 02222 22222 20022 02000 22000 00000 00000 000",
      "(2) 00010 00000 00110 00000 00000 00000 00000 00110 001",
      "(2) 02000 00000 00000 02200 20220 00002 20002 20000 002",
      "(2) 01000 00000 00000 01100 10000 00001 10001 10000 001",
      "(2) 01000 00000 00000 01100 10000 00001 10001 10000 001",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 001",
      "(2) 03000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 02101 00100 00000 00011 00000 01000 00000 00000 000",
      "(2) 01000 00000 00000 01100 10010 00001 10001 10000 001",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00010 000",
      "(2) 02000 00000 00000 02200 20220 00002 20002 20000 002",
      "(2) 01000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 02002 00000 00000 00000 00000 00000 00000 02000 000",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00110 000",
      "(2) 01000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 01000 00000 00000 01100 10210 00001 10001 10000 001",
      "(2) 01000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 01000 00000 00000 01100 10000 00001 10001 10000 001",
      "(2) 01010 00000 00000 00000 00001 00000 00110 00000 010",
      "(2) 01000 00000 00000 00000 00001 00000 00110 00000 010",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 001",
      "(2) 02202 00210 00000 00022 00000 02000 00000 00000 000",
      "(2) 00010 00001 00110 00000 00000 00000 00000 00110 001",
      "(2) 02000 00000 00000 02200 20220 00302 20002 20000 002",
      '01000 00000 00000 00000 00000 00000 00000 00000 000'B4,
      "(2) 01000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 00000 00000 00000 00000 00000 00000 00000 00000 001",
      "(2) 02202 00220 00000 00022 00000 02000 00000 00000 000",
      "(2) 01000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 01000 00000 00000 01100 10010 00001 10001 10001 001",
      "(2) 02002 00000 00000 00000 00000 00000 00000 01000 000",
      "(2) 02000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 02202 00220 00000 00022 00000 02000 00000 00000 000",
      "(2) 02202 01221 11000 00022 01000 02000 00000 00000 000",
      "(2) 02002 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 01000 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 01001 00000 00000 00000 00000 00000 00000 00000 000",
      "(2) 02202 02222 22110 00022 02000 02000 00000 00000 000",
      "(2) 00010 00000 00000 00000 00001 00000 00110 00000 010"); */

'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00100000000000000000000000000000101000001000101000000010001010000000101000000000000010'B,
'00101010100010101010101010101010000010100010000011101000000000001111000010000000001100'B,
'00000011000000000011000011110000000000000000000000000000000000000000000000111100000011'B,
'00000011000000000010000010100000000000000000000000000000000000000000000000101000000011'B,
'00100000000000000000000000000000101000001000001000000000001010000000101000000010000010'B,
'00000010000000000010000010100000000000000000000000000000000000000000000000101000000010'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00000001000001000000010101010000000000000000000000000000000000000000000000010100000001'B,
'00000010000001000000000010100000000000000000000000000000000000000000000000101000000010'B,
'00000010000001000000000010100000000000000000000000000000000000000000000000101000000010'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000010100000001'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000010100000001'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000010100000001'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000010100000001'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00010000000000000000000000000000000000000000000000000000010000010000000000000000000001'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000011'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00000000000000000000000000000000000001000000000000000000000000000000000000000000000000'B,
'00000001000000000000000001010000000000000000000000000000000000000000000000010100000001'B,
'00010000000000000000000000000000010100000100000000000000000101000000010100000000000001'B,
'00100000000000000000000000000000000000000000000000000000000000000000000000000000000001'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000010100000001'B,
'00100000000000000000000000000000101000001000000000000000001010000000101000000000000010'B,
'00100000000000000000000000000000101000001000000000000000001010000000101000000000000010'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000000000001'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000000000010'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00100000100000000000000000000000000000000000000000000000000000000000000010000000000000'B,
'00100000100000000000000000000000000000000000000000000000000000000000000010000000000000'B,
'00100001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000000000000001'B,
'00000001000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00101000100010101010101010101010000010100010000000101000000000000000000000000000000000'B,
'00101100100010101010101010101010000010100010000000101000000000000000000000000000000000'B,
'00100010000000000000000000000000000000000000000010000000000000001010000000000000001000'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000010000000000'B,
'00100000100000000000000000000000000000000000000000000000000000000000000010000000000000'B,
'00101111110110101010101010101010000010100010000010101000000000001010000000000000011000'B,
'00110000100000000000000000000000000000000000000000000000000000000000000010000000000000'B,
'00101000100010101010101010100101000010100010000000011000000000000000000000000000000000'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000000000001'B,
'00100000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00101000100010101010101010101010000010100010000000101000000000000000000000000000000000'B,
'00101000110011101010101010101010000010100010000000101000000000000000000000000000000000'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000100000000'B,
'00101100110010101010101010101010000010100010000000101000000000000000000000000000000000'B,
'00000001000000000000000001010000000000000000000000000000000000000000000000010100000001'B,
'00100000000000000000000000000000101000001000101000000000001010000000101000000000000010'B,
'00010000000000000000000000000000010100000100000000000000000101000000010100000000000001'B,
'00010000000000000000000000000000010100000100000000000000000101000000010100000000000001'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000000000001'B,
'00110000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00100100010000010000000000000000000001010000000000000100000000000000000000000000000000'B,
'00010000000000000000000000000000010100000100000100000000000101000000010100000000000001'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000100000000'B,
'00100000000000000000000000000000101000001000101000000000001010000000101000000000000010'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00100000100000000000000000000000000000000000000000000000000000000000000010000000000000'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000010100000000'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00010000000000000000000000000000010100000100100100000000000101000000010100000000000001'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00010000000000000000000000000000010100000100000000000000000101000000010100000000000001'B,
'00010001000000000000000000000000000000000000000001000000000000000101000000000000000100'B,
'00010000000000000000000000000000000000000000000001000000000000000101000000000000000100'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000000000001'B,
'00101000100000100100000000000000000010100000000000001000000000000000000000000000000000'B,
'00000001000000000001000001010000000000000000000000000000000000000000000000010100000001'B,
'00100000000000000000000000000000101000001000101000000011001010000000101000000000000010'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00000000000000000000000000000000000000000000000000000000000000000000000000000000000001'B,
'00101000100000101000000000000000000010100000000000001000000000000000000000000000000000'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00010000000000000000000000000000010100000100000100000000000101000000010100000001000001'B,
'00100000100000000000000000000000000000000000000000000000000000000000000001000000000000'B,
'00100000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00101000100000101000000000000000000010100000000000001000000000000000000000000000000000'B,
'00101000100001101001010100000000000010100001000000001000000000000000000000000000000000'B,
'00100000100000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00010000000000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00010000010000000000000000000000000000000000000000000000000000000000000000000000000000'B,
'00101000100010101010101001010000000010100010000000001000000000000000000000000000000000'B,
'00000001000000000000000000000000000000000000000001000000000000000101000000000000000100'B);

   DECLARE NC1TRIPLES FIXED BINARY (15) VALUE (203);
   DECLARE C1TRIPLES(0:NC1TRIPLES) FIXED BINARY (31) STATIC INITIAL (
      197379, 197385, 197388, 197389,
      197413, 197414, 197418, 207363, 459523, 459529, 459532, 459533, 459557,
      459558, 459562, 469507, 525059, 525065, 525068, 525069, 525093, 525094,
      525098, 535043, 590595, 590601, 590604, 590605, 590629, 590630, 590634,
      600579, 787203, 787209, 787212, 787213, 787237, 787238, 787242, 797187,
      852739, 852745, 852748, 852749, 852773, 852774, 852778, 862723, 918275,
      918281, 918284, 918285, 918309, 918310, 918314, 928259, 983811, 983817,
      983820, 983821, 983845, 983846, 983850, 993795, 1049347, 1049353, 1049356,
      1049357, 1049381, 1049382, 1049386, 1059331, 1124867, 1127174, 1180419,
      1180425, 1180428, 1180429, 1180453, 1180454, 1180458, 1190403, 1245955,
      1245961, 1245964, 1245965, 1245989, 1245990, 1245994, 1255939, 1377027,
      1377033, 1377036, 1377037, 1377061, 1377062, 1377066, 1387011, 1452547,
      1454852, 1454854, 1456897, 1639171, 1639177, 1639180, 1639181, 1639205,
      1639206, 1639210, 1649155, 1835779, 1835785, 1835788, 1835789, 1835813,
      1835814, 1835818, 1845763, 1911299, 2032387, 2032393, 2032396, 2032397,
      2032421, 2032422, 2032426, 2042371, 2228995, 2229001, 2229004, 2229005,
      2229029, 2229030, 2229034, 2238979, 2490904, 2490912, 2490913, 2490921,
      3212035, 3212041, 3212044, 3212045, 3212069, 3212070, 3212074, 3222019,
      3417602, 3539715, 3539721, 3539724, 3539725, 3539749, 3539750, 3539754,
      3549699, 3680771, 3683076, 3683078, 3685121, 3689499, 3746307, 3748612,
      3748614, 3750657, 3811843, 3814148, 3814150, 3936810, 4008451, 4010756,
      4010758, 4012801, 4072962, 4338946, 4338948, 4467203, 4469508, 4469510,
      4471553, 4598275, 4600580, 4600582, 4602625, 4664065, 4729601, 4794882,
      4794884, 4915971, 4915977, 4915980, 4915981, 4916005, 4916006, 4916010,
      4925955, 5188098, 5188100, 5384707, 5387012, 5387014, 5389057, 5833731,
      5833770);
   DECLARE PRTB(0:109) FIXED BINARY (31) STATIC INITIAL (
      0, 4671531, 18219, 18248, 4430, 4416, 4419,
      71, 17, 59, 45, 88, 81, 69, 77, 89, 0, 16949, 18730, 13350, 20266, 828,
      19260, 91, 36, 24, 42, 0, 0, 18730, 20266, 16949, 19260, 51, 42, 9, 10,
      11, 0, 0, 9, 0, 9, 0, 20, 0, 4156, 76, 0, 0, 0, 0, 10792, 0, 0, 82, 0, 23,
      46, 0, 0, 4072962, 91, 23052, 23053, 12, 13, 0, 17988, 82, 61, 11278,
      11279, 11289, 0, 29, 0, 0, 14393, 68, 61, 56, 0, 58, 1195027, 13105, 18,
      31, 28, 34, 82, 0, 83, 0, 15367, 0, 82, 0, 9, 0, 0, 3354940, 18952, 0,
      22070, 0, 22788, 35, 22037, 0);
   DECLARE PRDTB(0:109) FIXED BINARY(7) STATIC INITIAL (
      0, 35, 33, 34, 22, 23, 24, 32, 21, 6, 7,
      8, 9, 10, 11, 12, 13, 67, 37, 60, 64, 103, 105, 62, 68, 61, 106, 38, 65,
      39, 66, 69, 107, 73, 43, 85, 88, 89, 82, 72, 86, 83, 87, 84, 48, 40, 18,
      19, 49, 57, 59, 44, 53, 108, 109, 36, 58, 41, 47, 63, 104, 55, 54, 93, 94,
      95, 96, 92, 31, 42, 20, 98, 99, 100, 97, 46, 102, 101, 16, 3, 25, 15, 2,
      71, 28, 70, 27, 29, 30, 45, 17, 5, 56, 1, 75, 74, 14, 4, 79, 78, 52, 26,
      77, 76, 81, 80, 51, 50, 91, 90);
   DECLARE HDTB(0:109) UNSIGNED FIXED BINARY(8) STATIC INITIAL (
      0, 70, 70, 70, 61, 61, 61, 70, 61, 76, 76,
      76, 76, 76, 76, 76, 76, 65, 72, 43, 91, 50, 51, 62, 66, 52, 75, 73, 79,
      73, 79, 66, 75, 58, 82, 54, 54, 54, 54, 49, 54, 54, 54, 54, 46, 47, 56,
      57, 46, 43, 43, 81, 87, 53, 53, 71, 43, 47, 77, 91, 51, 83, 83, 90, 90,
      90, 90, 90, 88, 47, 45, 44, 44, 44, 44, 69, 50, 50, 63, 68, 61, 63, 68,
      59, 84, 59, 84, 64, 67, 81, 63, 55, 83, 48, 60, 60, 76, 55, 85, 85, 87,
      78, 74, 74, 80, 80, 89, 89, 86, 86);
   DECLARE PRLENGTH(0:109) FIXED BINARY(7) STATIC INITIAL (
      0, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 1, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 3, 3, 3, 3, 2, 2, 2, 2, 2,
      1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 1, 1, 1, 1, 3, 1, 1, 2, 1, 2, 2, 1, 1, 4, 2,
      3, 3, 2, 2, 1, 3, 2, 2, 3, 3, 3, 1, 2, 1, 1, 3, 2, 2, 2, 1, 2, 4, 3, 2, 2,
      2, 2, 2, 1, 2, 1, 3, 1, 2, 1, 2, 1, 1, 4, 3, 1, 3, 1, 3, 2, 3, 1);
   DECLARE CONTEXT_CASE(0:109) FIXED BINARY(7) STATIC INITIAL (
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
   DECLARE LEFT_CONTEXT(0:1) FIXED BINARY(7) STATIC INITIAL (86, 71);
   DECLARE LEFT_INDEX(0:49) FIXED BINARY(7) STATIC INITIAL (
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2);
   DECLARE CONTEXT_TRIPLE(0:0) FIXED BINARY (7) STATIC INITIAL (0);
   DECLARE TRIPLE_INDEX(0:49) FIXED BINARY(7) STATIC INITIAL (
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
   DECLARE PR_INDEX(0:91) FIXED BINARY(7) INITIAL (
      1, 17, 23, 29, 34, 35, 40, 40, 40, 40,
      42, 44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 46, 46, 46, 47, 48,
      48, 48, 49, 49, 50, 51, 52, 52, 52, 54, 55, 56, 56, 57, 61, 63, 68, 68,
      68, 71, 71, 71, 75, 77, 77, 78, 78, 83, 83, 83, 83, 84, 90, 90, 90, 92,
      92, 93, 93, 93, 94, 94, 94, 94, 94, 94, 96, 96, 98, 98, 98, 98, 100, 100,
      100, 101, 102, 104, 106, 108, 108, 108, 110, 110);

   /*  END OF CARDS PUNCHED BY SYNTAX                                      */

   /*  DECLARATIONS FOR THE SCANNER                                        */

   /* TOKEN IS THE INDEX INTO THE VOCABULARY V() OF THE LAST SYMBOL SCANNED,
      CH IS THE LAST CHARACTER SCANNED (HEX CODE),
      CP IS THE POINTER TO THE LAST CHARACTER SCANNED IN THE CARDIMAGE,
      BCD IS THE LAST SYMBOL SCANNED (LITERAL CHARACTER STRING). */
   DECLARE TOKEN UNSIGNED FIXED BINARY (8), CH BIT(8) ALIGNED, CP FIXED BINARY (15),
          BCD CHARACTER (256) VARYING, CH2 BIT(8) ALIGNED;

   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */
   DECLARE
      PAGE CHARACTER(1) INITIAL ('1'), DOUBLE CHARACTER(1) INITIAL ('0');

   /* LENGTH OF LONGEST SYMBOL IN V */
   DECLARE (RESERVED_LIMIT, MARGIN_CHOP) FIXED BINARY (31);

   /* CHARTYPE() IS USED TO DISTINGUISH CLASSES OF SYMBOLS IN THE SCANNER.
      TX() IS A TABLE USED FOR TRANSLATING FROM ONE CHARACTER SET TO ANOTHER.
      CONTROL() HOLDS THE VALUE OF THE COMPILER CONTROL TOGGLES SET IN $ CARDS.
      NOT_LETTER_OR_DIGIT() IS SIMILIAR TO CHARTYPE() BUT USED IN SCANNING
      IDENTIFIERS ONLY.

      ALL ARE USED BY THE SCANNER AND CONTROL() IS SET THERE.
   */
   DECLARE TX(0:255)  UNSIGNED FIXED BINARY(8) STATIC INITIAL ((256) 0),
      CHARTYPE(0:255) BIT(8) ALIGNED STATIC INITIAL( (256) (1) '00000001'B),
      CONTROL(0:255)  BIT(1) ALIGNED STATIC INITIAL ((256) (1) '0'B),
      NOT_LETTER_OR_DIGIT(0:255) BIT(1) ALIGNED STATIC INITIAL( (256) (1) '1'B);
   /* TRT USED FOR SCANNING BLANKS */
/****************************
   IF '0'B THEN
TRT:  CALL INLINE("DD"B4,0,0,3,0,CHARTYPE);        /* TRT 0(0,3),CHARTYPE  */
/****************************/

   /* ALPHABET CONSISTS OF THE SYMBOLS CONSIDERED ALPHABETIC IN BUILDING
      IDENTIFIERS     */

   /* BUFFER HOLDS THE LATEST CARDIMAGE,
      TEXT HOLDS THE PRESENT STATE OF THE INPUT TEXT (INCLUDING MACRO
      EXPANSIONS AND NOT INCLUDING THE PORTIONS DELETED BY THE SCANNER),
      TEXT_LIMIT IS A CONVENIENT PLACE TO STORE THE POINTER TO THE END OF TEXT,
      CARD_COUNT IS INCREMENTED BY ONE FOR EVERY XPL SOURCE CARD READ,
      ERROR_COUNT TABULATES THE ERRORS AS THEY ARE DETECTED DURING COMPILE,
      SEVERE_ERRORS TABULATES THOSE ERRORS OF FATAL SIGNIFICANCE.
   */
   DECLARE (BUFFER, TEXT, CURRENT_PROCEDURE, INFORMATION) CHARACTER (256) VARYING,
      (TEXT_LIMIT, CARD_COUNT, ERROR_COUNT, SEVERE_ERRORS, PREVIOUS_ERROR)
      FIXED BINARY (15) STATIC INITIAL (0)
      ;

   /* NUMBER_VALUE CONTAINS THE NUMERIC VALUE OF THE LAST CONSTANT SCANNED,
      JBASE CONTAINS THE FIELD WIDTH IN BIT STRINGS (DEFAULT VALUE = 4),
      BASE IS  2**JBASE   (I.E., SHL(1,JBASE) ).
   */
   DECLARE (NUMBER_VALUE, JBASE, BASE) FIXED BINARY (31);

   /* EACH OF THE FOLLOWING CONTAINS THE INDEX INTO V() OF THE CORRESPONDING
      SYMBOL.   WE ASK:    IF TOKEN = IDENT    ETC.    */
   DECLARE (IDENT, STRING, NUMBER, DIVIDE_OP, EOFILE, ORSYMBOL,
      CONCATENATE) FIXED BINARY (15);

   /* THE FOLLOWING ARE USED IN THE MACRO EXPANDER.  CONSIDERABLE LOGIC
      IS DEVOTED TO AVOIDING CREATING STRINGS OF LENGTH > 256, THE STRING LIMIT.
   */
   DECLARE BALANCE CHARACTER (256) VARYING, LB FIXED BINARY (31);
   DECLARE MACRO_LIMIT FIXED BINARY (7) VALUE (45),
      MACRO_NAME(0:MACRO_LIMIT) CHARACTER (256) VARYING,
      MACRO_TEXT(0:MACRO_LIMIT) CHARACTER (256) VARYING,
      MACRO_INDEX(0:256) UNSIGNED FIXED BINARY(8),
      TOP_MACRO FIXED BINARY (31) INITIAL ("FFFFFFFF"XN);
   DECLARE EXPANSION_COUNT FIXED BINARY (31) STATIC INITIAL (0),
      EXPANSION_LIMIT FIXED BINARY (15) VALUE (300);

   /* STOPIT() IS A TABLE OF SYMBOLS WHICH ARE ALLOWED TO TERMINATE THE ERROR
      FLUSH PROCESS.  IN GENERAL THEY ARE SYMBOLS OF SUFFICIENT SYNTACTIC
      HIERARCHY THAT WE EXPECT TO AVOID ATTEMPTING TO START COMPILING AGAIN
      RIGHT INTO ANOTHER ERROR PRODUCING SITUATION.  THE TOKEN STACK IS ALSO
      FLUSHED DOWN TO SOMETHING ACCEPTABLE TO A STOPIT() SYMBOL.
      FAILSOFT IS A BIT WHICH ALLOWS THE COMPILER ONE ATTEMPT AT A GENTLE
      RECOVERY.   THEN IT TAKES A STRONG HAND.   WHEN THERE IS REAL TROUBLE
      COMPILING IS SET TO FALSE, THEREBY TERMINATING THE COMPILATION.
      MAINLOC IS THE SYMBOL TABLE LOCATION OF COMPACTIFY FOR USE IN ERROR().
   */
   DECLARE STOPIT(0:NT) BIT(1) ALIGNED STATIC INITIAL ((*)'0'B),
       (FAILSOFT, COMPILING) BIT(1),
        MAINLOC FIXED BINARY (31);

   DECLARE S CHARACTER (256) VARYING;  /* A TEMPORARY USED VARIOUS PLACES */

   /* THE ENTRIES IN PRMASK() ARE USED TO SELECT OUT PORTIONS OF CODED
      PRODUCTIONS AND THE STACK TOP FOR COMPARISON IN THE ANALYSIS ALGORITHM */
   DECLARE PRMASK(0:5) FIXED BINARY (31) INITIAL (0, 0, 'FF'XN, 'FFFF'XN, 'FFFFFF'XN, 'FFFFFFFF'XN);

   DECLARE REST CHARACTER (256) VARYING; /* UNREAD PORTION OF SOURCE STATEMENT */
   /* SUBSTR(HEXCODES, I+1, 1) is the hexadecimal letter code for I */
   DECLARE HEXCODES CHARACTER(16) STATIC INITIAL ('0123456789ABCDEF');
 /*   DECLARE ALPHABET CHARACTER(30) STATIC INITIAL */
 /*       ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_$@#'); */
   /* To obtain upper & lower case, comment the previous line, and uncomment
      the following statement (this statement has not been tested):           */
 DECLARE ALPHABET CHARACTER(56) STATIC INITIAL
      ( 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$@#' );

   DECLARE CATNUMNTRY FIXED BINARY (31);

   /*THE PROPER SUBSTRING OF POINTER IS USED TO PLACE AN  |  UNDER THE POINT
      OF DETECTION OF AN ERROR DURING COMPILATION.  IT MARKS THE LAST CHARACTER
      SCANNED.  */
   DECLARE X70 CHARACTER(70) STATIC INITIAL(' ');
   DECLARE POINTER CHARACTER(80) STATIC INITIAL (((79)' ' || '|'));
   DECLARE (COUNT#STACK, COUNT#SCAN, COUNT#RR, COUNT#RX, COUNT#FORCE,
      COUNT#ARITH, COUNT#STORE, COUNT#FIXBFW, COUNT#FIXD, COUNT#FIXCHW,
      STACKMAX,
      COUNT#GETD, COUNT#GETC, COUNT#FIND) FIXED BINARY (31) STATIC INITIAL (0);

   /* RECORD THE TIMES OF IMPORTANT POINTS DURING COMPILATION */
   DECLARE CLOCK(0:5) FIXED BINARY (31);

   /* COUNT THE NUMBER OF COMPARISONS OF IDENTIFIERS IN SYMBOL TABLE LOOK-UPS
      THIS CAN, IN GENERAL, BE EXPECTED TO BE A SUBSTANTIAL PART OF RUN TIME.
   */
   DECLARE IDCOMPARES FIXED BINARY (31), STATEMENT_COUNT FIXED BINARY (31);
   DECLARE TRUELOC FIXED BINARY (31);  /* ADDRESS OF INTEGER 1 IN DATA AREA */
   DECLARE COMPLOC FIXED BINARY (31); /*  THE ADDRESS OF ALL ONES MASK FOR COMPLEMENT */
   DECLARE CATCONST FIXED BINARY (31);   /* ADDRESS OF 2**24  */
   DECLARE BASEDATA FIXED BINARY (31);   /*  BASE REGISTER INITIALIZATION ADDRESS */

   /*  THE EMITTER  ARRAYS  */


 /******************************************************************************

      WARNING:  THE EMITTER ARRAYS "CODE", "DATA", AND "STRINGS" ARE
   DEPENDENT ON THE HARDWARE DEVICES AVAILABLE FOR SCRATCH STORAGE.  THE
   LITERAL CONSTANT "DISKBYTES" SHOULD BE EQUAL TO THE BLOCKSIZE OF THESE FILES
   AS ESTABLISHED IN DCB'S IN THE SUBMONITOR.

   SUGGESTED VALUES:
            FOR LARGE CORE:             FOR SMALL CORE DISKBYTES = 400.

      2311     DISKBYTES = 3600
      2314     DISKBYTES = 7200
      2321     DISKBYTES = 2000

      THIS VERSION OF XCOM NEEDS THREE SCRATCH FILES:
      1        COMPILED CODE TEMPORARY
      2        COMPILED DATA TEMPORARY
      3        CHARACTER STRING TEMPORARY
      1        BINARY PROGRAM OUTPUT

 ******************************************************************************/

DECLARE DISKBYTES FIXED BINARY (15) VALUE (3600);    /*  2311  DISKS  */
      /* SIZE OF SCRATCH FILE BLOCKS IN BYTES */
   DECLARE CODEMAX FIXED BINARY (31);     /* FORCES CODE TO A WORD BOUNDARY */
   DECLARE CODE (0:DISKBYTES-1) BIT(8) ALIGNED;
   DECLARE DATAMAX FIXED BINARY (31);     /* FORCES DATA TO A WORD BOUNDARY */
   DECLARE DATA (0:DISKBYTES-1) BIT(8) ALIGNED;
   DECLARE STRNGMX FIXED BINARY (31);     /*  AND FORCE STRINGS TO BE ALIGNED  */
   DECLARE STRINGS (0:DISKBYTES-1) BIT(8) ALIGNED;  /* BUFFER FOR COMPILED STRINGS  */

   /* The next 3 lines define arrays to replace the small scratch files used */
   /* during code generation. */
   DECLARE CODE_ARRAY   (0:DISKBYTES*30) BIT(8) ALIGNED STATIC INITIAL ( (*) '0'B);
   DECLARE DATA_ARRAY   (0:DISKBYTES*30) BIT(8) ALIGNED STATIC INITIAL ( (*) '0'B);
   DECLARE STRING_ARRAY (0:DISKBYTES*30) BIT(8) ALIGNED STATIC INITIAL ( (*) '0'B);
   DECLARE JJ FIXED BINARY(31);

   /*  CODEMAX  IS THE # OF RECORDS OF CODE GENERATED
       DATAMAX IS THE NUMBER OF RECORDS OF DATA GENERATED
   */

   DECLARE CODEFILE FIXED BINARY (7) STATIC INITIAL(1);    /* FILE FOR BINARY CODE, AND */
   DECLARE BINARYFILE FILE RECORD;  /* COLLECTION OF ALL COMPILED OUTPUT */
   DECLARE DATAFILE FIXED BINARY (7) STATIC INITIAL (2);   /* SCRATCH FILE FOR DATA */
   DECLARE STRINGFILE FIXED BINARY (7) INITIAL (3);
                                                 /* SCRATCH FILE FOR CHARACTER STRINGS */

   DECLARE (PPORG, PPLIM, DPORG, DPLIM, CURCBLK, CURDBLK, CURSBLK, CHPORG,
      CHPLIM, STRINGMAX, SHORTDFIX, SHORTCFIX, LONGDFIX, LONGCFIX, FCP)
      FIXED BINARY (31) STATIC INITIAL (0);

      /* ARRAYS TO HOLD FIXUPS DURING COMPILATION */

   /* FCLIM IS THE NUMBER OF FIXUPS THAT CAN BE RECORDED BEFORE THEY ARE MADE */
   DECLARE FCLIM FIXED BINARY(7) VALUE (100);
   DECLARE FIXCADR (0:FCLIM) FIXED BINARY (31);      /* ADDRESS OF CODE FIXUP   */
   DECLARE FIXCB1  (0:FCLIM) BIT(8) ALIGNED;         /* 1ST BYTE OF CODE FIXUP  */
   DECLARE FIXCB2  (0:FCLIM) BIT(8) ALIGNED;         /* 2ND BYTE OF CODE FIXUP  */

   DECLARE LIMITWORD        FIXED BINARY (31) STATIC INITIAL (0);
   DECLARE STRING_RECOVER   FIXED BINARY (31) STATIC INITIAL (0);

   DECLARE CATENTRY FIXED BINARY (31);   /*  ENTRY TO CATENATE ROUTINE */
   DECLARE STRL  FIXED BINARY (31);  /* ADDRESS OF LAST STRING COMPUTED FOR OPTIMIZING || */
   DECLARE STRN  FIXED BINARY (31);  /* ADDRESS OF TEMP IN STRING TO NUMBER ROUTINE */
   DECLARE DESCL FIXED BINARY (31);
   DECLARE IO_SAVE FIXED BINARY (31);
   DECLARE NMBRNTRY  FIXED BINARY (31);       /*  ENTRY TO BINARY TO CHAR. CONVERSION */
   DECLARE TSA   FIXED BINARY (31);           /* INTEGER ADDRESS OF TOP-OF-STRINGS  */
   DECLARE MOVER FIXED BINARY (31);           /*  ADDRESS OF MOVE TEMPLATE  */
   DECLARE BASES (0:15) FIXED BINARY (31) STATIC INITIAL ((16)0);
                                              /*  THE VALUE OF THE BASE REGISTERS */
   DECLARE AVAIL FIXED BINARY (31) STATIC INITIAL (2);
   DECLARE INSTRUCT (0:255) FIXED BINARY (15)
           STATIC INITIAL ((*)0);             /*  INSTRUCTION USE COUNTERS */
   DECLARE DESC(0:1024) FIXED BINARY (31) STATIC INITIAL ((*)0);
                                              /* STRING DESCRIPTORS, REG 13 RELATIVE */

   /*  360 REGISTER ASSIGNMENTS:
            0     SCRATCH
            1-3   ACCUMULATORS
            4-11  DATA ADDRESSING
            12    BRANCH REGISTER
            13    STRING DESCRIPTOR AREA BASE
            14    PROGRAM BASE
            15    POINTS TO ENTRY OF I/O PACKAGE
   */

   DECLARE IOREG   UNSIGNED FIXED BINARY(8) VALUE (15);
                                        /* REGISTER FOR IO ROUTINES OF SUBMONITOR */
   DECLARE PBR     UNSIGNED FIXED BINARY(8) VALUE (14);
                                        /* PROGRAM BASE REGISTER POINTS TO CODE  */
   DECLARE SBR     UNSIGNED FIXED BINARY(8) VALUE (13);
                                        /* STRING BASE REGISTER TO ADDRESS DESCRIPT. */
   DECLARE BRCHREG UNSIGNED FIXED BINARY(8) VALUE (12); /* REGISTER FOR BRANCHING  */
   DECLARE DBR     UNSIGNED FIXED BINARY(8) VALUE (11); /* FIRST DATA BASE REGISTER  */
   DECLARE PROGRAMSIZE FIXED BINARY (7) VALUE (25);     /* NUMBER OF 4096 BYTE PAGES ALLOWED */
   DECLARE LASTBASE FIXED BINARY (7);   /*  KEEP TRACK OF ALLOCATION OF REG 11 - 4 */
   DECLARE TARGET_REGISTER FIXED BINARY (7);
   DECLARE MASKF000 BIT(32) ALIGNED;
   DECLARE ADREG  FIXED BINARY(31), ADRDISP FIXED BINARY (31); /* GLOBALS FOR FINDADDRESS */
   DECLARE RTNADR FIXED BINARY (31);  /*  WHERE THE PRESENT RETURN ADDRESS IS STORED */
   DECLARE RETURNED_TYPE BIT (8) ALIGNED;
      DECLARE TEMP(0:3) FIXED BINARY (15);
   DECLARE (DP, PP, CHP, DSP, NEWDP, NEWDSP) FIXED BINARY (31)
         STATIC INITIAL (0); /* EMITTER POINTERS */
   DECLARE ITYPE FIXED BINARY (31);   /*  INITIALIZATION TYPE  */
   DECLARE STILLCOND FIXED BINARY (31);  /*  REMEMBER CONDITION CODE TEST FOR PEEPHOLE */
   /* REMEMBER        FOR PEEP HOLE OPTIMISATION OF LENGTH FUNCTION */
   DECLARE SAVEADR FIXED BINARY (31), LENGTHPP FIXED BINARY (31), LENGTHPP2 FIXED BINARY (31);
   DECLARE NEG_INCREMENT BIT(8) ALIGNED;
   DECLARE M FIXED BINARY (31); /* A TEMPORARY */

   /*  COMMON  IBM  360  OP-CODES  */
   DECLARE OPNAMES CHARACTER(268) STATIC INITIAL(
      ('    BALRBCTRBCR LPR LNR LTR LCR NR  CLR OR  XR  LR  CR  AR  SR  MR  ' ||
       'DR  ALR SLR LA  STC IC  EX  BAL BCT BC  CVD CVB ST  N   CL  O   X   ' ||
       'L   C   A   S   M   D   AL  SL  SRL SLL SRA SLA SRDLSLDLSRDASLDAS   ' ||
       'TM  MVI NI  CLI OI  XI  LM  MVC STH LH  CH  AH  SH  MH  EDMKCLC '));
   DECLARE OPER(0:255) FIXED BINARY(7) STATIC INITIAL(
 /*0**/   0,  0,  0,  0,  0,  1,  2,  3,  0,  0,  0,  0,  0,  0,  0,  0,
 /*1**/   4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
 /*2**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*3**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*4**/  59, 20, 21, 22, 23, 24, 25, 26, 60, 61, 62, 63, 64,  0, 27, 28,
 /*5**/  29,  0,  0,  0, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
 /*6**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*7**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*8**/   0,  0,  0,  0,  0,  0,  0,  0, 42, 43, 44, 45, 46, 47, 48, 49,
 /*9**/  50, 51, 52,  0, 53, 54, 55, 56, 57,  0,  0,  0,  0,  0,  0,  0,
 /*A**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*B**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*C**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*D**/   0,  0, 58,  0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0, 65,
 /*E**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 /*F**/   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0);
 /*      *0  *1  *2  *3  *4  *5  *6  *7  *8  *9  *A  *B  *C  *D  *E  *F  */
   DECLARE OP_CODE CHARACTER (256) VARYING;  /* FOR DEBUG PRINTOUT */
   DECLARE COMMUTATIVE(0:63) BIT(1) STATIC ALIGNED;  /* RECORD WHICH OPERATORS ARE COMMUTATIVE */

   /* COMMONLY USED /360 OPERATION CODES */
   DECLARE BC    BIT(8) VALUE ('47'B4), BCR   BIT(8) VALUE ('07'B4),
           LOAD  BIT(8) VALUE ('58'B4), STORE BIT(8) VALUE ('50'B4),
           BAL   BIT(8) VALUE ('45'B4),
           BALR  BIT(8) ALIGNED STATIC INITIAL ('05'B4) ,
           CMPR  BIT(8) ALIGNED STATIC INITIAL ("59"B4),
           CMPRR BIT(8) ALIGNED STATIC INITIAL ("19"B4),
           LA    BIT(8) ALIGNED STATIC INITIAL ("41"B4),
           LR    BIT(8) ALIGNED STATIC INITIAL ('18'B4),
           AR    BIT(8) ALIGNED STATIC INITIAL ('1A'B4),
           SR    BIT(8) ALIGNED STATIC INITIAL ('1B'B4);

   /* THE FOLLOWING ARE USED TO HOLD ADDRESS PAIRS IN THE EMITTER FOR || */
   DECLARE A1 BIT(8) ALIGNED, A2 FIXED BINARY(15), T1 BIT(8) ALIGNED,
           B1 BIT(8) ALIGNED, B2 FIXED BINARY(15), T2 FIXED BINARY (15);

   /* COMMONLY USED STRINGS */
   DECLARE X1 CHARACTER(1) STATIC INITIAL(' '), X4 CHARACTER(4) STATIC INITIAL('    ');
   DECLARE EQUALS CHARACTER(4) STATIC INITIAL (' = '), PERIOD CHARACTER(1) STATIC INITIAL ('.');
   DECLARE
      CODEQ  CHARACTER(9) STATIC INITIAL(': CODE = '),
      DATAQ  CHARACTER(9) STATIC INITIAL(': DATA = '),
      VBAR   CHARACTER(1) STATIC INITIAL('|'),    X1VBAR CHARACTER(2) STATIC INITIAL(' |'),
      COLON  CHARACTER(1) STATIC INITIAL(':'),    COMMA  CHARACTER(1) STATIC INITIAL(','),
      LPAR   CHARACTER(1) STATIC INITIAL('('),    RPAR   CHARACTER(1) STATIC INITIAL(')'),
      FIXUPM CHARACTER(9) STATIC INITIAL(': FIXUP =');

   /* TEMPORARIES USED THROUGHOUT THE COMPILER */
   DECLARE CHAR_TEMP CHARACTER (256) VARYING;
   DECLARE (I, J, K, L) FIXED BINARY (31);

   DECLARE TRUE BIT(1) VALUE ('1'B), FALSE BIT(1) VALUE ('0'B);

   /*  SYMBOL  TABLE  VARIABLES  */

   DECLARE HALFWORD       FIXED BINARY (7) VALUE  (1),
           LABELTYPE      FIXED BINARY (7) VALUE  (2),
           ACCUMULATOR    FIXED BINARY (7) VALUE  (3),
           VARIABLE       FIXED BINARY (7) VALUE  (4),
           CONSTANT       FIXED BINARY (7) VALUE  (5),
           CONDITION      FIXED BINARY (7) VALUE  (6),
           CHRTYPE        FIXED BINARY (7) VALUE  (7),
           FIXEDTYPE      FIXED BINARY (7) VALUE  (8),
           BYTETYPE       FIXED BINARY (7) VALUE  (9),
           FORWARDTYPE    FIXED BINARY (7) VALUE (10),
           DESCRIPT       FIXED BINARY (7) VALUE (11),
           SPECIAL        FIXED BINARY (7) VALUE (12),
           FORWARDCALL    FIXED BINARY (7) VALUE (13) ,
           CHAR_PROC_TYPE FIXED BINARY (7) VALUE (14)
           ;
   DECLARE TYPENAME(0:14) CHARACTER (256) VARYING STATIC INITIAL (
      '', 'BIT(16)  ', 'LABEL    ', '', '',
      '', '', 'CHARACTER', 'FIXED    ', 'BIT(8)   ', '', '', '', '',
      'CHARACTER PROCEDURE');
   DECLARE PROCMARK FIXED BINARY (31);  /* START OF LOCAL VARIABLES IN SYMBOL TABLE */
   DECLARE PARCT FIXED BINARY (31);  /* NUMBER OF PARAMETERS TO CURRENT PROCEDURE */
   DECLARE NDECSY FIXED BINARY (31);     /* CURRENT NUMBER OF DECLARED SYMBOLS */
   /* MAXNDECSY IS THE MAXIMUM OF NDECSY OVER A COMPILATION.  IF MAXNDECSY
      BEGINS TO APPROACH SYTSIZE THEN SYTSIZE SHOULD BE INCREASED */
   DECLARE MAXNDECSY FIXED BINARY (31);

   DECLARE SYTSIZE FIXED BINARY(15) VALUE (470);

   /*  THE SYMBOL TABLE IS INITIALIZED WITH THE NAMES OF ALL
       BUILTIN FUNCTIONS AND PSEUDO VARIABLES.  THE PROCEDURE
       INITIALIZE DEPENDS ON THE ORDER AND PLACEMENT OF THESE
       NAMES.  DUE CAUTION SHOULD BE OBSERVED WHILE MAKING CHANGES.   */

   DECLARE SYT (0:SYTSIZE) CHARACTER (256) VARYING          /*  VARIABLE NAME */
      STATIC INITIAL ('','','MONITOR_LINK','TIME_OF_GENERATION',
         'DATE_OF_GENERATION','COREWORD','COREBYTE','FREEPOINT',
         'DESCRIPTOR','NDESCRIPT', 'LENGTH','SUBSTR','BYTE','SHL',
         'SHR','INPUT','OUTPUT','FILE','INLINE','TRACE','UNTRACE',
         'EXIT','TIME','DATE','CLOCK_TRAP','INTERRUPT_TRAP',
            'MONITOR', 'ADDR', 'COREHALFWORD', 'COMPACTIFY', '', '', (*)(1)'');
   DECLARE SYTYPE (0:SYTSIZE) UNSIGNED FIXED BINARY (8)   /* TYPE OF THE VARIABLE */
      STATIC INITIAL (0,0,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,
         BYTETYPE,FIXEDTYPE,FIXEDTYPE,FIXEDTYPE,SPECIAL,SPECIAL,
         SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,
         SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,SPECIAL,
         SPECIAL,SPECIAL,HALFWORD,FORWARDCALL,0,0, (*)0);
   DECLARE SYBASE(0:SYTSIZE) UNSIGNED FIXED BINARY(8) STATIC INITIAL(0, 0, PBR, DBR, DBR, 0, 0,
      DBR,SBR,DBR,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, (*)0);
   DECLARE SYDISP (0:SYTSIZE) UNSIGNED FIXED BINARY(12)  /* DISPLACEMENT FOR VARIABLE */
      ALIGNED STATIC INITIAL (0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,  10,11,12,13,14,
         15,16,17,18,19,0,0, (*)0);
   DECLARE SYTCO(0:SYTSIZE) FIXED BINARY (15);     /* COUNT OF REFERENCES TO SYMBOLS */
   DECLARE DECLARED_ON_LINE(0:SYTSIZE) FIXED BINARY (15);
   /* HASHING SYMBOL TABLE STUFF */
   DECLARE IDX       FIXED BINARY (15),
      PTR(0:SYTSIZE) FIXED BINARY (15) STATIC INITIAL ((SYTSIZE+1)-1),
      HASH(0:255)    FIXED BINARY (15) STATIC INITIAL ((256)-1);

   /*  THE COMPILER STACKS DECLARED BELOW ARE USED TO DRIVE THE SYNTACTIC
      ANALYSIS ALGORITHM AND STORE INFORMATION RELEVANT TO THE INTERPRETATION
      OF THE TEXT.  THE STACKS ARE ALL POINTED TO BY THE STACK POINTER SP.  */

   DECLARE STACKSIZE FIXED BINARY (7) VALUE (75);  /* SIZE OF STACK  */
   DECLARE PARSE_STACK (0:STACKSIZE) UNSIGNED FIXED BINARY(8) STATIC INITIAL ((*)0);
                                                         /* TOKENS OF THE PARTIALLY PARSED TEXT */
   DECLARE TYPE (0:STACKSIZE) UNSIGNED FIXED BINARY(8);  /* OPERAND TYPE FOR EXPRESSIONS */
   DECLARE REG  (0:STACKSIZE) UNSIGNED FIXED BINARY(8);  /* ASSOCIATED GENERAL REGISTER */
   DECLARE INX  (0:STACKSIZE) UNSIGNED FIXED BINARY(8);  /* ASSOCIATED INDEX REGISTER */
   DECLARE CNT  (0:STACKSIZE) UNSIGNED FIXED BINARY(8);  /* ANY COUNT, PARAMETERS, SUBSCRIPTS ...*/
   DECLARE VAR  (0:STACKSIZE) CHARACTER (256) VARYING STATIC INITIAL ((*)(1)'');
                                             /* EBCDIC or ASCII name of item */
   DECLARE FIXL (0:STACKSIZE) FIXED BINARY (31);   /* FIXUP LOCATION */
   DECLARE FIXV (0:STACKSIZE) FIXED BINARY (31);   /* FIXUP VALUE */
   DECLARE PPSAVE (0:STACKSIZE) FIXED BINARY (31); /* ASSOCIATED PROGRAM POINTER */

   /* SP POINTS TO THE RIGHT END OF THE REDUCIBLE STRING IN THE PARSE STACK, */
   /*      MP POINTS TO THE LEFT END, AND */
   /*      MPP1 = MP+1.   */

   DECLARE (SP, MP, MPP1) FIXED BINARY (15);

   /* DECLARE STATEMENTS AND CASE STATEMENTS REQUIRE AN AUXILIARY STACK */
   DECLARE CASELIMIT FIXED BINARY(15) VALUE (255),
        CASESTACK(0:CASELIMIT) FIXED BINARY (31);
   DECLARE CASEP FIXED BINARY (31);   /* POINTS TO THE CURRENT POSITION IN CASESTACK */
   DECLARE DCLRM CHARACTER(24) STATIC INITIAL ('IDENTIFIER LIST TOO LONG');




   /*               P R O C E D U R E S                                  */
   /*               ===================                                  */

/* This procedure packs a 4-byte integer into 4 BIT(8) units and stores them  */
/* in Array at subscript positiion <Subscript> to position <Subscript+3>.     */
PACK:
   PROCEDURE (Array, Word, Subscript);
      DECLARE Array (*) BIT (8) ALIGNED;
      DECLARE Word FIXED BINARY(31), Subscript FIXED BINARY (15);
      DECLARE Temp_word FIXED BINARY(31);
      DECLARE J FIXED BINARY(31);

      Temp_word = Word;
      DO J = Subscript+3 TO Subscript BY -1;
         Array(J) = BIT(BINARY(IAND(Temp_Word, '000000FF'B4), 8));
         Temp_Word = ISRL (Temp_Word, 8);
      END;
   END PACK;

XPL_TIME:
   PROCEDURE RETURNS (FIXED BINARY(31));
      DECLARE TIME_STRING CHARACTER (9),
              HH CHARACTER (2) DEFINED TIME_STRING,
              MM CHARACTER (2) DEFINED TIME_STRING POSITION (3),
              SS CHARACTER (2) DEFINED TIME_STRING POSITION (5),
              CS CHARACTER (2) DEFINED TIME_STRING POSITION (7);
      DECLARE TIME BUILTIN;

      TIME_STRING = TIME();
      RETURN ((HH*3600 + MM*60 + SS)*100 + CS);

   END XPL_TIME;

XPL_DATE:
   PROCEDURE RETURNS (FIXED BINARY(31));
      DECLARE DATETIME BUILTIN;

      RETURN ( BINARY(DATETIME('YYYYDDD')) - BINARY(1900000) );
   END XPL_DATE;

   DECLARE INLINE GENERIC (
      INLINE3 WHEN (*, *, *),
      INLINE4 WHEN (*, *, *, *),
      INLINE5 WHEN (*, *, *, *, *),
      INLINE6 WHEN (*, *, *, *, *, *)  );

INLINE3:
   PROCEDURE (OP, R1, R2);
      DECLARE OP BIT (8), (R1, R2) BIT (4);

END INLINE3;

INLINE4:
   PROCEDURE (OP, R1, R2, R3);
      DECLARE OP BIT (8) ALIGNED, (R1, R2, R3) BIT (4) ALIGNED;

END INLINE4;

INLINE5:
   PROCEDURE (OP, R1, R2, R3, R4);
      DECLARE OP BIT (8), (R1, R2, R3, R4) BIT (4);

END INLINE5;

INLINE6:
   PROCEDURE (OP, R1, R2, R3, R4, R5);
      DECLARE OP BIT (8), (R1, R2, R3, R4, R5(*)) BIT (4);

END INLINE6;

   DECLARE BYTE GENERIC (
      BYTE_VARYING WHEN (VARYING),
      BYTE_UNVARYING WHEN (*),
      BYTE_VARYING2 WHEN (VARYING, *),
      BYTE_UNVARYING2 WHEN (*, *) );

/* These four procedures convert XPL's BYTE, which assumes that the first character is */
/* at position 0, to PL/I form, in which the first character is at position 1. */
BYTE_UNVARYING:
   PROCEDURE (String) RETURNS (BIT(8));
      DECLARE String CHARACTER (*);
      DECLARE Ch CHARACTER (1);

      Ch = SUBSTR(String, 1, 1);
      RETURN (UNSPEC (Ch));
   END BYTE_UNVARYING;

BYTE_VARYING:
   PROCEDURE (String) RETURNS (BIT(8));
      DECLARE String CHARACTER (*) VARYING;
      DECLARE Ch CHARACTER (1);

      Ch = SUBSTR(String, 1, 1);
      RETURN (UNSPEC (Ch));
   END BYTE_VARYING;

BYTE_UNVARYING2:
   PROCEDURE (String, Position) RETURNS (BIT(8));
      DECLARE String CHARACTER (*);
      DECLARE Position FIXED BINARY (15);
      DECLARE Ch CHARACTER (1);

      Ch = SUBSTR(String, Position+1, 1);
      RETURN (UNSPEC (Ch));
   END BYTE_UNVARYING2;

BYTE_VARYING2:
   PROCEDURE (String, Position) RETURNS (BIT(8));
      DECLARE String CHARACTER (*) VARYING;
      DECLARE Position FIXED BINARY (15);
      DECLARE Ch CHARACTER (1);

      Ch = SUBSTR(String, Position+1, 1);
      RETURN (UNSPEC (Ch));
   END BYTE_VARYING2;

PAD:
   PROCEDURE (STRING, WIDTH) RETURNS (CHARACTER (256) VARYING);
      DECLARE STRING CHARACTER (*) VARYING, (WIDTH, L) FIXED BINARY (31);

      L = LENGTH(STRING);
      IF L >= WIDTH THEN RETURN (STRING);
      ELSE RETURN (STRING || SUBSTR((200)' ', 1, WIDTH-L));
   END PAD;

I_FORMAT:
   PROCEDURE (NUMBER, WIDTH) RETURNS (CHARACTER (256) VARYING);
         DECLARE NUMBER FIXED BINARY (31), (WIDTH, L) FIXED BINARY (15),
            STRING CHARACTER (15) VARYING;

      STRING = TRIM(NUMBER);
      L = LENGTH(STRING);
      IF L >= WIDTH THEN RETURN (STRING);
      ELSE RETURN (SUBSTR(X70, 1, WIDTH-L) || STRING);
   END I_FORMAT;


LISTER:
   PROCEDURE;
   /* S = I_FORMAT(PP, 6); */
      PUT SKIP EDIT ( I_FORMAT(CARD_COUNT, 4), X1VBAR, BUFFER, VBAR,
                       TRIM(PP), REST, CURRENT_PROCEDURE, INFORMATION) (A);
   END LISTER;

DECLARE ERROR GENERIC (
   ERROR3 WHEN (VARYING),
   ERROR1 WHEN (*),
   ERROR4 WHEN (VARYING, *),
   ERROR2 WHEN (*, *));

ERROR1:
   PROCEDURE (Message);
      DECLARE Message CHARACTER (*) VARYING;

      CALL ERROR (Message, 0);
   END ERROR1;

ERROR3:
   PROCEDURE (Message);
      DECLARE Message CHARACTER (*);
      DECLARE MessageV CHARACTER(LENGTH(MESSAGE)) VARYING;

      MessageV = Message;
      CALL ERROR1 (MessageV);
   END ERROR3;

ERROR4:
   PROCEDURE (MessageV, Severity);
      DECLARE MessageV CHARACTER (*) VARYING, SEVERITY FIXED BINARY (15);
      DECLARE Message CHARACTER (LENGTH(MessageV));

      Message = MessageV;
      CALL ERROR2 (Message, Severity);
END ERROR4;

ERROR2:
   PROCEDURE(MSG, SEVERITY);
      /* PRINTS AND ACCOUNTS FOR ALL ERROR MESSAGES */
      /* IF SEVERITY IS NOT SUPPLIED, 0 IS ASSUMED */
      DECLARE MSG CHARACTER (*), SEVERITY FIXED BINARY (15);

      ERROR_COUNT = ERROR_COUNT + 1;
      /* IF LISTING IS SUPPRESSED, FORCE PRINTING OF THIS LINE */
      IF ^ CONTROL(BYTE('L')) THEN
         CALL LISTER;
ON FIXEDOVERFLOW SNAP BEGIN;
  put skip data (text_limit, lb, cp, margin_chop);
  go to last;
end;
ON STRINGRANGE SNAP BEGIN;
  put skip data (text_limit, lb, cp, margin_chop);
   put skip list('TEXT_LIMIT+LB-CP+MARGIN_CHOP+1=', TEXT_LIMIT+LB-CP+MARGIN_CHOP+1);
  go to last;
end;

      PUT SKIP EDIT ( '|' ) (COLUMN(TEXT_LIMIT+LB-CP+MARGIN_CHOP+2), A);
      /* Original was in error; TEXT_LIMIT+LB-CP+MARGIN_CHOP yielded -1. */
last: revert fixedoverflow; revert stringrange;

      PUT SKIP EDIT ( '*** ERROR, ', MSG) (A);

      SIGNAL CONDITION(TRACEBACK); /* To obtain a traceback to reveal the calling procedure. */

      IF ERROR_COUNT>1 THEN
         PUT SKIP EDIT ( 'LAST PREVIOUS ERROR WAS DETECTED ON LINE ', PREVIOUS_ERROR) (A);
      PREVIOUS_ERROR = CARD_COUNT;
      IF SEVERITY > 0 THEN
         IF SEVERE_ERRORS > 25 THEN
            DO;
               PUT SKIP LIST ('*** TOO MANY SEVERE ERRORS, COMPILATION ABORTED ***');
               COMPILING = FALSE;
            END;
         ELSE SEVERE_ERRORS = SEVERE_ERRORS + 1;
   END ERROR2;


   /*                      FILE HANDLING PROCEDURES                          */
   /*                      ========================                          */



GETDATA:
   PROCEDURE;
      /* HANDLE SCRATCH STORAGE ALLOCATION FOR THE DATA ARRAY  */
      DECLARE I FIXED BINARY (31);

      COUNT#GETD = COUNT#GETD + 1;
/*      WRITE FILE(DATAFILE) FROM (DATA) KEY (CURDBLK); */    /*  WRITE OUT CURRENT BLOCK */
      DO JJ = 0 TO DISKBYTES-1;
         DATA_ARRAY(JJ + DISKBYTES*CURDBLK) = DATA(JJ);
      END;
      CURDBLK = DP / DISKBYTES;          /* CALCULATE NEW BLOCK NUMBER */
      DPORG = CURDBLK * DISKBYTES;
      DPLIM = DPORG + DISKBYTES;
      IF CURDBLK <= DATAMAX THEN
         DO;
/*            READ FILE(DATAFILE) INTO (DATA) KEY(CURDBLK); */
            DO JJ = 0 TO DISKBYTES-1;
               DATA(JJ) = DATA_ARRAY(JJ + DISKBYTES*CURDBLK);
            END;
         END;
      ELSE
         DO;
            /*  ZERO OUT THE NEW DATA BLOCK  */
            DATA = 0;
            DO DATAMAX = DATAMAX + 1 TO CURDBLK - 1;
/*               WRITE FILE(DATAFILE) FROM (DATA) KEY (DATAMAX); */
            END;
         END;
   END  GETDATA;

GETCODE:
   PROCEDURE;
      /*  HANDLE SCRATCH STORAGE ALLOCATION FOR THE CODE ARRAY */
      DECLARE I FIXED BINARY (31);

      COUNT#GETC = COUNT#GETC + 1;
/*      FILE(CODEFILE,CURCBLK) = CODE; */
      DO JJ = 0 TO DISKBYTES-1;
         CODE_ARRAY(JJ+CURCBLK*DISKBYTES) = CODE(JJ);
      END;
      CURCBLK = PP / DISKBYTES;       /* CALCULATE NEW BLOCK NUMBER */
      PPORG = CURCBLK * DISKBYTES;
      PPLIM = PPORG + DISKBYTES;
      IF CURCBLK <= CODEMAX THEN
         DO;
/*              CODE = FILE(CODEFILE,CURCBLK); */
            DO JJ = 0 TO DISKBYTES-1;
               CODE(JJ) = CODE_ARRAY(JJ + DISKBYTES*CURCBLK);
            END;
         END;
      ELSE
         DO;
         /*  ZERO OUT THE NEW CODE BLOCK */
              CODE = 0;
            DO CODEMAX = CODEMAX + 1 TO CURCBLK - 1;
/*               FILE(CODEFILE,CODEMAX) = CODE; */
            END;
         END;
   END  GETCODE;

GETSTRINGS:
   PROCEDURE;

      /* HANDLE SCRATCH STORAGE ALLOCATION FOR STRING ARRAY */
/*      FILE(STRINGFILE, CURSBLK) = STRINGS;    /* WRITE INTO THE FILE */
      DO JJ = 0 TO DISKBYTES-1;
         STRING_ARRAY(JJ + DISKBYTES*CURSBLK) = STRINGS(JJ);
      END;
      CURSBLK = CHP / DISKBYTES;              /* COMPUTE NEW BLOCK NUMBER */
      CHPORG = CURSBLK*DISKBYTES;             /* NEW BLOCK ORIGIN */
      CHPLIM = CHPORG + DISKBYTES;            /* NEW UPPER BOUND */
      IF CURSBLK <= STRINGMAX THEN
         DO;
/*           STRINGS = FILE(STRINGFILE,CURSBLK);  /* READ BACK FROM FILE */
            DO JJ = 0 TO DISKBYTES-1;
               STRINGS(JJ) = STRING_ARRAY(JJ + DISKBYTES*CURSBLK);
            END;
         END;
      ELSE
         DO STRINGMAX = STRINGMAX+1 TO CURSBLK - 1;
/*            FILE(STRINGFILE,STRINGMAX) = STRINGS; */
            /* FILL OUT FILE SO NO GAPS EXIST */
            DO JJ = 0 TO DISKBYTES-1;
               STRING_ARRAY(JJ + DISKBYTES*STRINGMAX) = STRINGS(JJ);
            END;
         END;
   END GETSTRINGS;



  /*                   CARD IMAGE HANDLING PROCEDURE                      */
  /*                   =============================                      */


GET_CARD:
   PROCEDURE;
      /* DOES ALL CARD READING AND LISTING                                 */
      DECLARE I FIXED BINARY (15), READING BIT(1) STATIC INITIAL ('0'B),
         (TEMP, TEMP0) CHARACTER (256) VARYING;
         /* temp AND temp0 DO NOT APPEAR TO BE USED. */

      IF LB > 0 THEN
         DO;
            TEXT = BALANCE;
            TEXT_LIMIT = LB - 1;
            LB,CP=0;
            RETURN;
         END;
      EXPANSION_COUNT = 0;   /* CHECKED IN SCANNER MACRO EXPANSION */
      IF READING THEN
         DO; /* 'READING' IS FALSE DURING COMPILE OF LIBRARY FROM INPUT(2) */
            ON ENDFILE (SYSIN) BEGIN;
                BUFFER = '';
                GO TO END_SYSIN;
            END;

            GET FILE (SYSIN) EDIT (BUFFER) (L);
            IF LENGTH(BUFFER) < 80 THEN
               BUFFER = PAD(BUFFER, 80);
END_SYSIN:
            REVERT ENDFILE (SYSIN);

            IF LENGTH(BUFFER) = 0 THEN
               DO; /* SIGNAL FOR EOF */
                  CALL ERROR ('EOF MISSING OR COMMENT STARTING IN COLUMN 1.',1);
                  BUFFER = PAD (' /*''/* */ EOF;END;EOF', 80);
               END;
            ELSE CARD_COUNT = CARD_COUNT + 1;  /* USED TO PRINT ON LISTING */
         END;
      ELSE
         DO; /* WHILE READING LIBRARY FILE ONLY */
            ON ENDFILE (LIBRARY) BEGIN;
                BUFFER = '';
                GO TO END_LIBRARY;
            END;

            GET FILE (LIBRARY) EDIT (BUFFER) (L);
            IF LENGTH(BUFFER) < 80 THEN
               BUFFER = PAD(BUFFER, 80);
END_LIBRARY:
            REVERT ENDFILE (LIBRARY);

            IF LENGTH(BUFFER) = 0 THEN
               DO;  /* SIGNAL TO SWITCH TO SYSIN */
                  CONTROL(BYTE('D')),   /* TURN ON THE SYMBOL DUMP */
                  CONTROL(BYTE('L')), READING = TRUE;  /* TURN ON LISTING */
                  CLOCK(1) = XPL_TIME();  /* KEEP TRACK OF TIME FOR COMPILE RATE */
                  TEXT = X1;  /* INITIALIZE TEXT FOR SCAN */
                  /* STATEMENTS ARE COUNTED FOR STATISTICS */
                  STATEMENT_COUNT = -1;
                  TEXT_LIMIT = 0;
                  PROCMARK = NDECSY + 1;
                  RETURN;
               END;
         END;
      IF MARGIN_CHOP > 0 THEN
         DO; /* THE MARGIN CONTROL FROM DOLLAR | */
            I = LENGTH(BUFFER) - MARGIN_CHOP;
            REST = SUBSTR(BUFFER, I+1);
            BUFFER = SUBSTR(BUFFER, 1, I);
         END;
      ELSE REST = '';
      TEXT = BUFFER;
      TEXT_LIMIT = LENGTH(TEXT) - 1;
      IF CONTROL(BYTE('M')) THEN PUT SKIP LIST (BUFFER);
      ELSE IF CONTROL(BYTE('L')) THEN
         CALL LISTER;
      INFORMATION = '';
      CP = 0;
   END GET_CARD;


   /*                THE SCANNER PROCEDURES              */
   /*                ======================              */


CHAR:
   PROCEDURE;
      /* USED FOR STRINGS TO AVOID CARD BOUNDARY PROBLEMS */
      CP = CP + 1;
      IF CP <= TEXT_LIMIT THEN RETURN;
      CALL GET_CARD;
   END CHAR;

DEBLANK:
   PROCEDURE;
      /* USED BY BCHAR */
      CALL CHAR;
      DO WHILE (SUBSTR(TEXT, CP+1, 1) = ' ');
         CALL CHAR;
      END;
   END DEBLANK;

BCHAR:
   PROCEDURE;
      /* USED FOR BIT STRINGS */
      DO FOREVER;
         CALL DEBLANK;
         CH = BYTE(TEXT, CP);
         IF CH ^= BYTE('(') THEN RETURN;
         /*  (BASE WIDTH)  */
         CALL DEBLANK;
         JBASE = BYTE(TEXT, CP) - BYTE('0');  /* WIDTH */
         IF JBASE < 1 | JBASE > 4 THEN
            DO;
               CALL ERROR ('ILLEGAL BIT STRING WIDTH: ' || SUBSTR(TEXT, CP+1, 1));
               JBASE = 4;  /* DEFAULT WIDTH FOR ERROR */
            END;
         BASE = ISLL(1, JBASE);
         CALL DEBLANK;
         IF BYTE(TEXT, CP) ^= BYTE(')') THEN
            CALL ERROR ('MISSING ) IN BIT STRING', 0 );
      END;
   END BCHAR;

BUILD_BCD:
   PROCEDURE (C);
      DECLARE C BIT(8);
      DECLARE Chr CHARACTER (1);

      UNSPEC (Chr) = C;
      IF LENGTH(BCD) > 0 THEN
         BCD = BCD || Chr;
      ELSE
         BCD = Chr;
   END BUILD_BCD;

SCAN:
   PROCEDURE;
      DECLARE (S1, S2) FIXED BINARY (31);
      DECLARE LSTRNGM CHARACTER(15) STATIC INITIAL('STRING TOO LONG');

      COUNT#SCAN = COUNT#SCAN + 1;
      FAILSOFT = TRUE;
      BCD = '';  NUMBER_VALUE = 0;
   SCAN1:
      DO FOREVER;
         IF CP > TEXT_LIMIT THEN CALL GET_CARD;
         ELSE
            DO; /* DISCARD LAST SCANNED VALUE */
               TEXT_LIMIT = TEXT_LIMIT - CP;
               TEXT = SUBSTR(TEXT, CP+1);
               CP = 0;
            END;
/*PUT skip list('SCAN: BYTE(TEXT) =', BYTE(TEXT), 'CHAR=',
    SUBSTR(TEXT, MIN(CP+1, LENGTH(TEXT)), 1));
PUT SKIP LIST ('SCAN: CHARTYPE(BYTE(TEXT))=', CHARTYPE(BYTE(TEXT)) );*/

         /*  BRANCH ON NEXT CHARACTER IN TEXT                  */
         SELECT (CHARTYPE(BYTE(TEXT)) );

            /* CASE 0:  BLANK */
            WHEN (0)
            DO;
/*               CALL INLINE ("58", 3, 0, TEXT);   /* L   3,TEXT     */
               /* LOAD DESCRIPTOR FOR TEXT & ZERO THE LENGTH FIELD */
/*               CALL INLINE("41", 3, 0, 3, 1);
               /* LOAD LENGTH INTO R2 */
/*               CALL INLINE("58",2,0,TEXT_LIMIT); /* L   2,TEXT_LIMIT*/
               /* POINT R1 JUST PAST TEXT_LIMIT IN CASE REST OF TEXT IS BLANK */
/*               CALL INLINE ("41",1,2,3,0);       /* LA  1,0(2,3)    */
               /* EXECUTE TRT TO SKIP OVER BLANKS */
/*************   CALL INLINE ("44", 2, 0, TRT);     /* EX  2,TRT      */
               /* COMPUTE NEW VALE OF CP POINTING @ LAST BLANK */
/*               CALL INLINE("1B", 1, 3);          /* SR  1,3     */
/*               CALL INLINE("50", 1, 0, CP);      /* ST  1,CP    */
               CP = 1;
/*               DO FOREVER;
                  IF CP > TEXT_LIMIT THEN LEAVE;
                  IF SUBSTR(TEXT, CP+1, 1) ^= ' ' THEN LEAVE;
                  CP = CP + 1;
               END; */
               IF CP <= TEXT_LIMIT THEN
                  IF SUBSTR(TEXT, 2, 1) = ' ' THEN
                     DO;
                        CP = VERIFY(TEXT, ' '); /* Fast search. */
                           /* (Don't bother using SUBSTR to omit the first character.) */
                        IF CP = 0 THEN
                           CP = LENGTH(TEXT); /* Did not find a non-blank. */
                        ELSE
                           CP = CP - 1; /* XPL strings start at position 0. */
                     END;
               CP = CP - 1;
               /* CP IS INCREMENTED BY 1 at END OF CASE ON CHARTYPE */
            END;

            /* CASE 1:   ILLEGAL CHARACTERS FALL HERE  */
            WHEN (1) CALL ERROR ('ILLEGAL CHARACTER: ' || SUBSTR(TEXT, 1, 1));


            /*  CASE 2  */

            /*  STRING QUOTE ('):  CHARACTER STRING  */
            WHEN (2)
            DO FOREVER;
               TOKEN = STRING;
               CALL CHAR; S1 = CP;
               DO WHILE (BYTE(TEXT,CP) ^= BYTE(''''));
                  CP = CP + 1;
                  IF CP > TEXT_LIMIT THEN
                     DO;
                        IF LENGTH(BCD)+CP-S1 > 256 THEN
                           DO;
                              CALL ERROR(LSTRNGM, 0);
                              RETURN;
                           END;
                        BCD = BCD || SUBSTR(TEXT,S1+1,CP-S1);
                        CP,S1=0;
                        CALL GET_CARD;
                     END;
               END;
               IF LENGTH(BCD)+CP-S1 > 256 THEN
                  DO;
                     CALL ERROR(LSTRNGM,0);
                     RETURN;
                  END;
               IF CP > S1 THEN
                  BCD = BCD || SUBSTR(TEXT,S1+1,CP-S1);
               CALL CHAR;
               IF BYTE(TEXT, CP) ^= BYTE('''') THEN /* Not an embedded apostrophe; finish. */
                  RETURN;

               /* Continue here when there is a repeated apostrophe within a string. */
               IF LENGTH(BCD) > 255 THEN
                  DO;
                     CALL ERROR(LSTRNGM,0);
                     RETURN;
                  END;
               BCD = BCD || ''''; /* Stores the duplicated apostrophe as one apostrophe. */
               TEXT_LIMIT = TEXT_LIMIT - CP;
               TEXT = SUBSTR(TEXT,CP+1);
               CP = 0;   /* PREPARE TO RESUME SCANNING STRING */
            END;

            /*  CASE 3  */

            WHEN (3)
            DO;      /*  BIT QUOTE("):  BIT STRING  */
               JBASE = 4;  BASE = ISLL(1, JBASE);  /* DEFAULT WIDTH  */
               TOKEN = NUMBER;  /* ASSUME SHORT BIT STRING */
               S1 = 0;
               CALL BCHAR;
               DO WHILE (CH ^= BYTE('"'));
                  S1 = S1 + JBASE;
                  IF CH >= BYTE('0') & CH <= BYTE ('9') THEN S2 = CH - BYTE('0');  /* DIGITS */
                  ELSE S2 = CH - BYTE('A') + 10;              /* LETTERS A-F*/
                  IF S2 >= BASE | S2 < 0 THEN
                     DO;
                     CALL ERROR ('ILLEGAL CHARACTER IN BIT STRING: '
                     || SUBSTR(TEXT, CP+1, 1));
                        IF CH=BYTE(';') THEN RETURN; /* GET OUT OF TROUBLE */
                     END;
                  IF S1 > 32 THEN TOKEN = STRING;     /* LONG BIT STRING */
                  IF TOKEN = STRING THEN
                     DO WHILE (S1 - JBASE >= 8);
                        IF LENGTH(BCD) > "FF"XN THEN
                           DO;
                              CALL ERROR (LSTRNGM, 0);
                              RETURN;
                           END;
                        S1 = S1 - 8;
                        CALL BUILD_BCD ( BIT(BINARY(IAND(ISRL(NUMBER_VALUE, S1-JBASE), 255), 8)) );
                        /* Previous line modified with IAND 13/4/2001. */
                     END;
                  NUMBER_VALUE = ISLL(NUMBER_VALUE, JBASE) + S2;
                  CALL BCHAR;
               END;     /* OF DO WHILE CH...  */
               CP = CP + 1;
               IF TOKEN = STRING THEN
                  IF LENGTH(BCD) > "FF"XN THEN CALL ERROR (LSTRNGM, 0);
                  ELSE CALL BUILD_BCD (BIT(BINARY(IAND(ISLL(NUMBER_VALUE, 8 - S1), 255), 8)));
                        /* The above line modified with IAND 13/4/2001. */
               RETURN;
            END;

            /*  CASE 4  */

            WHEN (4)
            DO FOREVER;  /* A LETTER:  IDENTIFIERS AND RESERVED WORDS */
               DO CP = CP + 1 TO TEXT_LIMIT;
                  IF NOT_LETTER_OR_DIGIT(BYTE(TEXT, CP)) THEN
                     DO;  /* END OF IDENTIFIER  */
                        IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 1, CP);
                        S1 = LENGTH(BCD);
                        IF S1 > 1 THEN IF S1 <= RESERVED_LIMIT THEN
                           /* CHECK FOR RESERVED WORDS */
                           DO I = V_INDEX(S1-1) TO V_INDEX(S1) - 1;
                              IF BCD = V(I) THEN
                                 DO;
                                    TOKEN = I;
                                    RETURN;
                                 END;
                           END;
                        DO I = MACRO_INDEX(S1-1) TO MACRO_INDEX(S1) - 1;
                           IF BCD = MACRO_NAME(I) THEN
                              DO;
                                 BCD = MACRO_TEXT(I);
                                 IF EXPANSION_COUNT < EXPANSION_LIMIT THEN
                                    EXPANSION_COUNT = EXPANSION_COUNT + 1;
                                 ELSE
                                    CALL ERROR('TOO MANY EXPANSIONS FOR ' ||
                                    MACRO_NAME(I) || 'LITERALLY: ' || BCD, 1);
                                 TEXT = SUBSTR(TEXT, CP+1);
                                 TEXT_LIMIT = TEXT_LIMIT - CP;
                                 IF LENGTH(BCD) + TEXT_LIMIT > 255 THEN
                                    DO;
                                       IF LB + TEXT_LIMIT > 255 THEN
                                         CALL ERROR('MACRO EXPANSION TOO LONG');
                                       ELSE
                                          DO;
                                             BALANCE = TEXT || BALANCE;
                                             LB = LENGTH(BALANCE);
                                             TEXT = BCD;
                                          END;
                                    END;
                                 ELSE TEXT = BCD || TEXT;
                                 BCD = '';
                                 TEXT_LIMIT = LENGTH(TEXT) - 1;
                                 CP = 0;
                                 GO TO SCAN1;
                              END;
                        END;
                        /*  RESERVED WORDS EXIT HIGHER: THEREFORE <IDENTIFIER>*/
                        TOKEN = IDENT;
                        RETURN;
                     END;
               END;
               /*  END OF CARD  */
               BCD = BCD || TEXT;
               CALL GET_CARD;
               CP = -1;
            END;

            /*  CASE 5  */

            WHEN (5)
            DO;      /*  DIGIT:  A NUMBER  */
               TOKEN = NUMBER;
               DO FOREVER;
                  DO CP = CP TO TEXT_LIMIT;
                     S1 = BYTE(TEXT, CP);
                     IF S1 < BYTE('0') | S1 > BYTE ('9')  THEN RETURN;
                     NUMBER_VALUE = 10*NUMBER_VALUE + S1 - BYTE('0');
                  END;
                  CALL GET_CARD;
               END;
            END;

            /*  CASE 6  */

            WHEN (6)
            DO;      /*  A /:  MAY BE DIVIDE OR START OF COMMENT  */
               CALL CHAR;
               IF BYTE(TEXT, CP) ^= BYTE('*') THEN
                  DO;
                     TOKEN = DIVIDE_OP;
                     RETURN;
                  END;
               /* WE HAVE A COMMENT  */
                  CH,CH2 = BYTE(' ');
                 DO WHILE (CH ^= BYTE('*') | CH2 ^= BYTE('/') );
                IF CH=BYTE('^') & CH2=BYTE('$') THEN
                     DO; /* TURN OFF THE TOGGLE */
                        CH = CH2; CALL CHAR; CH2 = BYTE(TEXT, CP);
                        CONTROL(CH2) = FALSE;
                        IF CH2=BYTE('T') THEN CALL UNTRACE; ELSE
                        IF CH2=BYTE('U') THEN CALL TRACE;
                     END;
                 ELSE
                 IF CH = BYTE('$') THEN
                     DO; /* A CONTROL CHARACTER */
                        CONTROL(CH2) = TRUE;
                        IF CH2 = BYTE('T') THEN CALL   TRACE;
                        ELSE IF CH2 = BYTE('U') THEN CALL UNTRACE;
                        ELSE IF CH2 = BYTE('|') THEN
                           IF CONTROL(CH2) THEN
                              MARGIN_CHOP = 1 + TEXT_LIMIT - CP;
                           ELSE
                              MARGIN_CHOP = 0;
                     END;
                  CH = CH2;
                  CALL CHAR;
                  CH2 = BYTE(TEXT, CP);
               END;
            END;

            /*  CASE 7  */
            WHEN (7)
            DO;      /*  SPECIAL CHARACTERS  */
               TOKEN = TX(BYTE(TEXT));
               CP = 1;
               RETURN;
            END;

            /*  CASE 8  */

            WHEN (8)
            DO;  /* A |:  MAY BE "OR" OR "CAT"  */
               CALL CHAR;
               IF BYTE(TEXT, CP) = BYTE('|') THEN
                  DO;
                     CALL CHAR;
                     TOKEN = CONCATENATE;
                  END;
               ELSE TOKEN = ORSYMBOL;
               RETURN;
            END;

         END;     /* OF SELECT ON CHARTYPE  */
         CP = CP + 1;  /* ADVANCE SCANNER AND RESUME SEARCH FOR TOKEN  */
      END;
   END SCAN;


  /*             ADDRESS AND REGISTER COMPUTATIONS                       */
  /*             =================================                       */


CHECKBASES:
   PROCEDURE;
      IF ^ COMPILING THEN RETURN;
      IF DP >= BASES(LASTBASE) + 4096 THEN
         DO;
            LASTBASE = LASTBASE - 1;  /* USE REG 11 DOWN TO REG 4 */
            BASES(LASTBASE) = IAND(DP, "00FFFFFC"B4);
            INFORMATION = INFORMATION || ' R' || TRIM(LASTBASE) || EQUALS ||
               TRIM(BASES(LASTBASE)) || PERIOD;
            IF LASTBASE = 3 THEN CALL ERROR('EXCEEDED DATA AREA',1);
         END;
   END  CHECKBASES;

CLEARREGS:
   PROCEDURE;
      /* FREE ALL THE ARITHMETIC REGISTERS  */
      TARGET_REGISTER=3;
CLEARIT:
      BASES(TARGET_REGISTER)= AVAIL;
      TARGET_REGISTER = TARGET_REGISTER - 1;
      IF TARGET_REGISTER>=0 THEN GOTO CLEARIT; /* LEAVES -1 IN TARGET_REGISTER*/
   END  CLEARREGS;

FINDAC:
   PROCEDURE RETURNS (FIXED BINARY (7) );
      /*  FIND AN ACCUMULATOR FOR 32 BIT QUANTITY  */
      DECLARE I FIXED BINARY (7);

      IF TARGET_REGISTER>=0 THEN IF BASES(TARGET_REGISTER) = AVAIL THEN
         DO;
            BASES(TARGET_REGISTER) = ACCUMULATOR;
            RETURN (TARGET_REGISTER);
         END;
      DO I = 1 TO 3;
         IF BASES(I) = AVAIL THEN
            DO;
               BASES(I) = ACCUMULATOR;
               RETURN (I);
            END;
      END;
      CALL ERROR('USED ALL ACCUMULATORS',0);
      RETURN (0);
   END  FINDAC;


FINDADDRESS:
   PROCEDURE (ADR);
      /* FIND THE APPROPRIATE BASE AND DISPLACEMENT FOR THE ADDRESS  */
      DECLARE (ADR, I) FIXED BINARY (31);

      COUNT#FIND = COUNT#FIND + 1;
      IF ADR < 0 THEN
         DO;
            ADRDISP = - ADR;
            ADREG = SBR;
            RETURN;
         END;
      IF ADR = 0 THEN
         DO;
            ADREG,ADRDISP = 0;
            RETURN;
         END;
      DO I = LASTBASE TO DBR;
         IF BASES(I) <= ADR & BASES(I)+4096 > ADR THEN
            DO;
               ADRDISP = ADR - BASES(I);
               ADREG = I;
               RETURN;
            END;
      END;

      CALL ERROR('FIND ADDRESS FAILED', 1);
      ADREG,ADRDISP = 0;
   END  FINDADDRESS;




  /*                    CODE EMISSION PROCEDURES                       */
  /*                    ========================                       */


EMITCHAR:
   PROCEDURE (C);
      DECLARE C BIT (8);

      /*  SEND ONE 8-BIT CHARACTER TO THE STRING AREA  */
      IF CONTROL(BYTE('E')) THEN
         PUT SKIP EDIT (CHP, ': CHARACTER = ',
            SUBSTR(HEXCODES, ISRL(C,4)+1, 1), SUBSTR(HEXCODES, (C & "0F"B4)+1, 1) ) (COL(70), 4 A);
      IF CHP < CHPORG | CHP >= CHPLIM THEN CALL GETSTRINGS;
      STRINGS(CHP-CHPORG) = C;
      CHP = CHP + 1;
   END  EMITCHAR;

EMITBYTE:
   PROCEDURE (B);
      DECLARE B BIT(8) ALIGNED;

      /*  EMIT ONE BYTE OF DATA  */
      IF DP < DPORG | DP >= DPLIM THEN CALL GETDATA;
      DATA(DP-DPORG) = B;
      IF CONTROL(BYTE('E')) THEN
         PUT SKIP LIST ( DP ||  DATAQ ||
            SUBSTR(HEXCODES, ISRL(B,4)+1, 1) || SUBSTR(HEXCODES, (B & "0F"B4)+1, 1) );
      DP = DP + 1;
      CALL CHECKBASES;
   END EMITBYTE;

EMITCODEBYTES:
   PROCEDURE (B1, B2, WHERE);
      DECLARE (B1, B2) BIT(8) ALIGNED, WHERE FIXED BINARY (31);
      DECLARE I FIXED BINARY (31);

on subscriptrange begin;
  put skip list ('i=', i, 'pp=', pp, 'pporg=', pporg, 'pplim=', pplim);
end;

      ON ERROR SNAP BEGIN;
         PUT SKIP EDIT ('called from line ' || TRIM(WHERE), '.' ) (A);
      END;

      /*  EMIT TWO BYTES OF CODE  */
      SAVEADR ,
      STILLCOND = 0;
      IF PP < PPORG | PP >= PPLIM THEN CALL GETCODE;
      I = PP - PPORG;
      CODE(I) = B1;             /*  FIRST  BYTE  */
      CODE(I+1) = B2;           /*  SECOND  BYTE  */
      IF CONTROL(BYTE('B')) THEN
         PUT SKIP EDIT ( PP, CODEQ,
            SUBSTR(HEXCODES, ISRL(B1,4)+1, 1), SUBSTR(HEXCODES, (B1 & "0F"B4)+1, 1),
            SUBSTR(HEXCODES, ISRL(B2,4)+1, 1), SUBSTR(HEXCODES, (B2 & "0F"B4)+1,1) ) (A);
      PP =  PP + 2;
   END  EMITCODEBYTES ;

EMITDATAWORD:
   PROCEDURE(W);
      DECLARE (W, I) FIXED BINARY (31);

      /*  SEND A 32-BIT WORD TO THE DATA ARRAY  */
      DP = IAND(DP + 3, "00FFFFFC"B4);
      IF DP < DPORG | DP >= DPLIM THEN CALL GETDATA;
      CALL CHECKBASES;
      IF CONTROL(BYTE('E')) THEN
         PUT SKIP EDIT ( DP, DATAQ, W )(A);
      I = ISRL(DP-DPORG, 2) +1; /* CONVERT TO WORD ADDRESSING */
      /* DATAMAX(I)=W; */
      CALL PACK (DATA, W, DP-DPORG); /***************CHECK +1 ???????????? */
      DP = DP + 4;
      CALL CHECKBASES;
   END EMITDATAWORD;

EMITDESC:
   PROCEDURE (D);
      DECLARE D FIXED BINARY (31);

      /*  SEND 32-BIT DESCRIPTOR TO STRING DESCRIPTOR AREA  */
      IF DSP >= 4096 THEN
         DO;
            CALL ERROR ('TOO MANY STRINGS', 1);
            RETURN;
         END;
      IF CONTROL(BYTE('E')) THEN
         PUT SKIP EDIT (DSP, ': DESC = ', TRIM(ISRL(D,24)), ', ', TRIM(IAND(D, "FFFFFF"B4)) )
            (COL(70), 5 A);
      DESC(ISRL(DSP,2)) = D;
      DSP = DSP + 4;
   END EMITDESC;

EMITCONSTANT:
   PROCEDURE(C);
      /* SEE IF C HAS ALREADY BEEN EMITTED, AND IF NOT, EMIT IT.  SET UP ADDRESS */
      DECLARE CTAB(0:59) FIXED BINARY (31) STATIC, CADD(0:59) UNSIGNED FIXED BINARY (16) STATIC,
         C FIXED BINARY (31), I FIXED BINARY (15),
         NC FIXED BINARY (15) STATIC INITIAL(-1);

      DO I = 0 TO NC;
         IF CTAB(I) = C THEN
            DO;
               ADREG = IAND(ISRL(CADD(I), 12), "F"B4); /* & TO REMOVE SIGN BIT */
               ADRDISP = IAND(CADD(I), "FFF"B4);
               RETURN;
            END;
      END;
      CALL EMITDATAWORD (C);
      CTAB(I) = C;
      CALL FINDADDRESS(DP-4);

      CADD(I) = ISLL(ADREG,12) + ADRDISP;
      IF I<59 THEN NC=I;
      INFORMATION = INFORMATION || ' C' || TRIM(I) || EQUALS || TRIM(C) || PERIOD;
   END EMITCONSTANT;

EMITRR:
   PROCEDURE (OP, R1, R2, WHERE);
      DECLARE OP BIT(8) ALIGNED, (R1, R2) UNSIGNED FIXED BINARY(8);
      DECLARE WHERE FIXED BINARY (31);

      ON ERROR SNAP BEGIN;
         PUT SKIP EDIT ('called from line ' || TRIM(WHERE), '.' ) (A);
      END;

      /* EMIT A 16-BIT RR FORMAT INSTRUCTION  */
      COUNT#RR = COUNT#RR + 1;
      IF CONTROL(BYTE('E')) THEN
         DO;
            OP_CODE = SUBSTR(OPNAMES, ISLL(OPER(OP), 2)+1, 4);
            PUT SKIP EDIT ( PP, CODEQ, OP_CODE, X1, TRIM(R1), COMMA, TRIM(R2) )(A);
         END;
      CALL EMITCODEBYTES(OP, BIT(BINARY(ISLL(R1,4)+R2, 8)), SOURCELINE() );
      INSTRUCT(OP) = INSTRUCT(OP) + 1;
   END EMITRR;

   DECLARE EMITRX GENERIC (
      EMITRX1 WHEN (*, *, *, *, BIT),
      EMITRX2 WHEN (*, *, *, *, *));

EMITRX1:
   PROCEDURE (OP, R1, R2, R3, DISP);
      DECLARE OP BIT(8) ALIGNED, (R1, R2, R3) UNSIGNED FIXED BINARY(8), DISP BIT(12) ALIGNED;

      CALL EMITRX2 (OP, R1, R2, R3, BINARY(DISP, 31));
   END EMITRX1;

EMITRX2:
   PROCEDURE (OP, R1, R2, R3, DISP);
      DECLARE OP BIT(8) ALIGNED, (R1, R2, R3) UNSIGNED FIXED BINARY(8), DISP FIXED BINARY (31);

      ON SIZE SNAP BEGIN;
         put skip data(r1, r2, r3, disp);
         GO TO LAST;
      END;

      /*  EMIT A 32-BIT RX FORMAT INSTRUCTION */
      COUNT#RX = COUNT#RX + 1;
      IF CONTROL(BYTE('E')) THEN
         DO;
            OP_CODE = SUBSTR(OPNAMES, ISLL(OPER(OP), 2)+1, 4);
            PUT SKIP EDIT ( PP, CODEQ, OP_CODE, X1, TRIM(R1), COMMA, TRIM(DISP),
               LPAR, TRIM(R2), COMMA, TRIM(R3), RPAR )(A);
         END;
      CALL EMITCODEBYTES(OP, BIT(BINARY(ISLL(R1,4)+R2, 8)), SOURCELINE() );
      CALL EMITCODEBYTES(BIT (BINARY(ISLL(R3,4)+ISRL(DISP,8), 8)),
           BIT (BINARY(IAND(DISP, "FF"B4), 8)), SOURCELINE());
      INSTRUCT(OP) = INSTRUCT(OP) + 1;
LAST:
   END EMITRX2;


EMITSS:
   PROCEDURE(OP, LENGTH, AD1, AD2);
      /* EMIT A 48-BIT SS INSTRUCTION */
      DECLARE (OP, LENGTH) BIT(8) ALIGNED, (AD1, AD2) FIXED BINARY (31);

      IF CONTROL(BYTE('E')) THEN
         DO;
            OP_CODE = SUBSTR(OPNAMES,ISLL(OPER(OP),2)+1,4);
            PUT SKIP EDIT ( PP, CODEQ, OP_CODE, X1, TRIM(IAND(AD1, "00000FFF"B4)), LPAR,
                     TRIM(LENGTH+1), COMMA, TRIM(IAND(ISRL(AD1, 12), "F"B4)), '),' ,
                     TRIM(IAND(AD2, "00000FFF"B4)), LPAR,
                     TRIM(IAND(ISRL(AD2, 12), "0000000F"B4)), RPAR )(A);
         END;
      CALL EMITCODEBYTES(OP, LENGTH, SOURCELINE() );
      CALL EMITCODEBYTES(BIT(BINARY(ISRL(AD1,8), 8)), BIT(BINARY(IAND(AD1, 'FF'B4), 8)),
         SOURCELINE() );
      CALL EMITCODEBYTES(BIT(BINARY(ISRL(AD2,8), 8)), BIT(BINARY(IAND(AD2, 'FF'B4),
       8)), SOURCELINE() );
      INSTRUCT(OP) = INSTRUCT(OP)+1;
   END  EMITSS;


LOAD_CONSTANT:
   PROCEDURE(OP, REG, CONST);
      DECLARE REG UNSIGNED FIXED BINARY(8), OP BIT(8) ALIGNED,
         CONST FIXED BINARY (31);
HALF_CONST:
   PROCEDURE;
      /* EMITS HALFWORD CONSTANTS. SEE IF CONST HAS ALREADY BEEN EMITTED.
         IF NOT, SET UP, ADDRESS */
      DECLARE CTAB(0:49) FIXED BINARY (15) STATIC, CADD(0:49) UNSIGNED FIXED BINARY (16) STATIC,
         C FIXED BINARY (31), I FIXED BINARY (15),
         NC FIXED BINARY (15) STATIC INITIAL (-1);
ON SUBSCRIPTRANGE SNAP BEGIN;
   PUT SKIP LIST(I, C, NC, CONST);
   GO TO SUBR;
END;
ON SIZE SNAP BEGIN;
   PUT SKIP LIST(I, C, NC, CONST);
   GO TO SUBR;
END;

      DO I = 0 TO NC;
         IF CTAB(I) = CONST THEN
            DO;
                ADREG = IAND (ISRL(CADD(I),12), 'F'B4);
                ADRDISP = IAND(CADD(I), "00000FFF"B4);
                RETURN;
            END;
      END;
      DP=IAND(DP,1)+DP; /* ALIGN HALFWORD BOUNDARY */
      CTAB(I) = CONST;
      CALL FINDADDRESS(DP);
      CALL EMITBYTE(BIT(BINARY(IAND(ISRL(CONST, 8), 'FF'B4), 8)));
      CALL EMITBYTE(BIT(BINARY(IAND(CONST, "FF"B4), 8)));
      CADD(I)= IOR(ISLL(ADREG,12), ADRDISP);
SUBR: REVERT SIZE;
      IF I<49 THEN NC=I;
      INFORMATION = INFORMATION || ' CH'|| TRIM(I) || EQUALS || TRIM(CONST) || PERIOD;
   END HALF_CONST;

      IF (((OP>=LOAD) & (OP<='5C'B4)) | (OP='50'B4)) &
         (CONST>=ISLL('FFFF80'B4, 8)) & (CONST<='FFFF'B4) THEN
         DO;
            IF OP='5C'B4 THEN REG=BIT(BINARY(REG+1, 8)); /* Multiplication is a special case. */
            CALL HALF_CONST;
            OP = OP & 'EF'B4; /* HALFWORD OPERATION CODE */
                        /* The AND operation effectively subtracts 16. */
         END;
      ELSE CALL EMITCONSTANT (CONST);
      CALL EMITRX(OP, REG, 0, ADREG, ADRDISP);
   END LOAD_CONSTANT;


  /*                       FIXUP PROCEDURES                                  */
  /*                       ================                                  */



INSERT_CODE_FIXUPS:
   PROCEDURE;
      /* EMPTY THE FIXUP TABLE, EITHER FOR LOADING OR BECAUSE OF
         TABLE OVERFLOW */
      DECLARE (I, J, L, FXLIM, T1, K) FIXED BINARY (31);
      DECLARE T2 BIT(8), EXCHANGES BIT(1);

      /* THE FIRST STEP IS TO SORT THE CODE FIXUP TABLE */
      K,FXLIM = FCP - 1;     EXCHANGES = TRUE;
      DO WHILE (EXCHANGES);  /* QUIT BUBBLE SORT AFTER TABLE QUIETS DOWN */
         EXCHANGES = FALSE;  /* RESET ON EACH EXCHANGE BELOW */
         DO J = 0 TO K-1;
            I = FXLIM-J;
            L = I-1;
            IF FIXCADR(L) > FIXCADR(I) THEN
               DO;  /* SWAP */
                  T1 = FIXCADR(L);  FIXCADR(L) = FIXCADR(I);  FIXCADR(I) = T1;
                  T2 = FIXCB1(L);   FIXCB1(L)  = FIXCB1(I);   FIXCB1(I)  = T2;
                  T2 = FIXCB2(L);   FIXCB2(L)  = FIXCB2(I);   FIXCB2(I)  = T2;
                  EXCHANGES = TRUE;  K = J;
               END;
         END;
      END;

      /* NOW WRITE OUT THE CURRENT BLOCK */
/*      FILE(CODEFILE,CURCBLK) = CODE; */
      DO JJ = 0 TO DISKBYTES-1;
         CODE_ARRAY(JJ + DISKBYTES*CURCBLK) = CODE(JJ);
      END;

      /* WRITE BINARY PROGRAM PATCHES INTO PROGRAM FILE */

      K,PPORG=0;  PPLIM = DISKBYTES;
      DO J = 0 TO CODEMAX;

         I = K;  /* KEEP TRACK OF K SO THAT WE WILL KNOW WHEN TO READ IN */

         DO WHILE ((K <= FXLIM)  &  (FIXCADR(K) < PPLIM));
            /* IF THE FILE HAS NOT YET BEEN READ IN, DO SO */
            IF K = I THEN
               DO;
/*                  CODE = FILE(CODEFILE,J); /* ONLY IF A FIX IS NEEDED */
                  DO JJ = 0 TO DISKBYTES-1;
                     CODE(JJ) = CODE_ARRAY(JJ + DISKBYTES*J);
                  END;
               END;
            L = FIXCADR(K) - PPORG;  /* RELATIVE ADDRESS WITHIN THIS BLOCK */
            CODE(L) = FIXCB1(K);  CODE(L+1) = FIXCB2(K);
            K = K + 1;
         END;

         IF K > I THEN    /* A FIXUP WAS DONE */
            DO;
/*            FILE(CODEFILE,J) = CODE;  /* SO WRITE OUT THE CONTENTS */
               DO JJ = 0 TO DISKBYTES-1;
                  CODE_ARRAY(JJ + DISKBYTES*J) = CODE(JJ);
               END;
            END;

         PPORG = PPORG + DISKBYTES;
         PPLIM = PPLIM + DISKBYTES;
      END;

      FCP = 0;  /* RESET TABLE TO EMPTY */
/*      CODE = FILE(CODEFILE,CURCBLK);  /* RESTORE FILE TO PREVIOUS STATE */
      DO JJ = 0 TO DISKBYTES-1;
         CODE(JJ) = CODE_ARRAY(JJ + DISKBYTES*CURCBLK);
      END;
      PPORG = CURCBLK*DISKBYTES;  PPLIM = PPORG + DISKBYTES;
   END INSERT_CODE_FIXUPS;

FIXCHW:
   PROCEDURE (ADR, B1, B2);
      DECLARE ADR FIXED BINARY (31), (B1, B2) BIT(8) ALIGNED;

      /*  FIX UP ONE HALF WORD OF CODE  */
      COUNT#FIXCHW = COUNT#FIXCHW + 1;
      IF FCP >= FCLIM THEN
         CALL INSERT_CODE_FIXUPS;
      IF PPORG <= ADR & ADR < PPLIM THEN
         DO;
            SHORTCFIX = SHORTCFIX + 1;
            ADR = ADR - PPORG;
            CODE(ADR) = B1;
            CODE(ADR+1) = B2;
         END;
      ELSE
         DO;
            LONGCFIX = LONGCFIX + 1;
            FIXCADR(FCP) = ADR;
            FIXCB1(FCP) = B1;
            FIXCB2(FCP) = B2;
            FCP = FCP + 1;
         END;
   END  FIXCHW;


FIXBFW:
   PROCEDURE (WHERE, VALUE);
      DECLARE (WHERE, VALUE, I, J, P) FIXED BINARY (31);
      DECLARE VAL FIXED BINARY(31);

      IF WHERE = 0 THEN RETURN;
      VAL = VALUE;
      /* FIX UP A BRANCH WHOSE ADDRESS WE NOW KNOW */
      COUNT#FIXBFW = COUNT#FIXBFW + 1;
      IF CONTROL(BYTE('E')) THEN
         PUT SKIP EDIT(TRIM(WHERE), FIXUPM, TRIM(VAL))(X(4), A);
      P = WHERE + 2;       /* THE ACTUAL ADDRESS FIELD  */
      I = IAND(VAL, "00000FFF"XN);  J = ISLL(ISRL(VAL,12), 2);
      IF WHERE > "FFF"XN THEN
         DO;
            CALL FIXCHW(P, BIT(BINARY(ISLL(DBR,4), 8)), BIT(BINARY(J, 8)));
            VAL = I;
            P = P + 4;
         END;
      ELSE IF VAL >= "1000"XN THEN
         DO;
            INSTRUCT(LOAD) = INSTRUCT(LOAD) + 1;
            INSTRUCT(BC) = INSTRUCT(BC) + 1;
            CALL EMITDATAWORD(ISLL(BRCHREG+"580"XN, 20)+ISLL(DBR, 12) + J);
            CALL EMITDATAWORD(ISLL("47F0"XN+BRCHREG, 16) + ISLL(PBR, 12) + I);
            CALL FINDADDRESS (DP-8);
            CALL FIXCHW(P, BIT(BINARY(ISLL(ADREG,4)+ISRL(ADRDISP,8), 8)),
               BIT(BINARY(IAND(ADRDISP, "FF"B4), 8)));
            RETURN;
         END;
      CALL FIXCHW(P, BIT(BINARY(ISLL(PBR,4)+ISRL(VAL,8), 8)), BIT(BINARY(IAND(VAL, "FF"B4), 8)));
   END FIXBFW;


FIXWHOLEDATAWORD:
   PROCEDURE (ADR, WORD);
      DECLARE (ADR, WORD) FIXED BINARY (31);
      DECLARE (BLK, TEMP) FIXED BINARY (31);

      IF CONTROL(BYTE('E')) THEN
         PUT SKIP EDIT ( ADR, FIXUPM, WORD) (A);
      COUNT#FIXD = COUNT#FIXD + 1;
      BLK = ADR/DISKBYTES;
      IF CURDBLK^=BLK THEN
         DO;  /* MUST GET THE RIGHT BLOCK  */
            LONGDFIX = LONGDFIX + 1;
            TEMP = DP;
            DP = ADR;
            CALL GETDATA;
            DP = TEMP;
         END;
      ELSE SHORTDFIX = SHORTDFIX + 1;
      ADR = MOD (ADR, DISKBYTES);
         /* SHIFT TO WORD INDEXING */
         /* DATAMAX(ISRL(ADR,2)+1) = WORD; */
         CALL PACK (DATA, WORD, ADR); /*  ***********MAY NEED TO ADJUST +1 ??????? */
   END  FIXWHOLEDATAWORD;


HASHER:
   PROCEDURE(ID) RETURNS (FIXED BINARY (16));
      DECLARE ID CHARACTER (*) VARYING, L FIXED BINARY (15);

/*      CALL INLINE("1B"B4, 0, 0); */
/*      L = INLINE("43"B4,0, 0,ID) + 1; /* LENGTHS ARE ALWAYS >=1 */
      L = LENGTH(ID);

      RETURN ( IAND(BYTE(ID)+BYTE(ID,L-1)+ISLL(L,4), "FF"B4) );
   END HASHER;

ENTER:
   PROCEDURE (N, T, L, LINE) RETURNS (FIXED BINARY (15));
      /*  ENTER A SYMBOL IN THE SYMBOL TABLE  */
      DECLARE (I, J, K, L, T, LINE) FIXED BINARY (31), N CHARACTER (*) VARYING;

      IDX = HASHER(N);
      I = HASH(IDX);
      DO WHILE (I>= PROCMARK);
         /* NOW TEST FOR NAMES USING INDIRECT INDICES */
         IDCOMPARES = IDCOMPARES + 1;
         IF N = SYT(I) THEN
            DO;
               K = SYTYPE(I);
               IF T = LABELTYPE & (K = FORWARDTYPE | K = FORWARDCALL) THEN
                  DO;
                     IF CONTROL(BYTE('E')) THEN
                        PUT SKIP EDIT ('FIX REFERENCES TO: ', N) (COL(70), A, A);
                     J = BASES(SYBASE(I))+ SYDISP(I);
                     IF K = FORWARDCALL THEN
                        L = L + 4 + ISLL(L>"FFF"B4, 2);
                     SYBASE(I) = BIT(BINARY(ISRL(L, 12), 4));
                     SYDISP(I) = BIT(BINARY(IAND(L, "FFF"B4), 12));
                     CALL FIXWHOLEDATAWORD(J,L);
                     SYTYPE(I) = BIT(BINARY(T, 8));
                  END;
               ELSE IF PROCMARK + PARCT < I THEN
                  CALL ERROR('DUPLICATE DECLARATION FOR:  ' || N, 0);
               DECLARED_ON_LINE(I) = LINE;
               RETURN (I);
            END;
         I = PTR(I);  /* CHECK NEXT LINK */
      END;
      NDECSY = NDECSY + 1;
      IF NDECSY > MAXNDECSY THEN
         IF NDECSY > SYTSIZE THEN
            DO;
               CALL ERROR ('SYMBOL TABLE OVERFLOW', 1);
               NDECSY = NDECSY - 1;
            END;
         ELSE MAXNDECSY = NDECSY;
      SYT(NDECSY) = N;
      /* LINK IN HASH ID AS LEGAL */
      PTR(NDECSY) = HASH(IDX);
      HASH(IDX) = NDECSY;
      SYTYPE(NDECSY) = BIT(BINARY(T, 8));
      DECLARED_ON_LINE(NDECSY) = LINE;
      SYTCO(NDECSY) = 0;
      IF T = LABELTYPE THEN
         DO;
            SYBASE(NDECSY) = BIT(BINARY(ISRL(L, 12), 4));  /* PAGE  */
            SYDISP(NDECSY) = BIT(BINARY(IAND(L, "FFF"B4), 12));
         END;
      ELSE
         DO;
            CALL FINDADDRESS(L);
            SYBASE(NDECSY) = BIT(BINARY(ADREG, 4));
            SYDISP(NDECSY) = BIT(BINARY(ADRDISP, 12));
         END;
      IDCOMPARES = IDCOMPARES + NDECSY - PROCMARK;
      RETURN (NDECSY);
   END  ENTER;

ID_LOOKUP:
   PROCEDURE (P);
       /* LOOKS UP THE IDENTIFIER AT P IN THE ANALYSIS STACK IN THE
          SYMBOL TABLE AND INITIALIZES FIXL,CNT,TYPE,REG,INX
          APPROPRIATELY.  IF THE IDENTIFIER IS NOT FOUND, FIXL IS
          SET TO -1
       */
       DECLARE P FIXED BINARY (15), I FIXED BINARY (31);

      CHAR_TEMP = VAR(P);
      I = HASH(HASHER(CHAR_TEMP));
      DO WHILE (I ^= -1);
         IDCOMPARES = IDCOMPARES+1;
         IF SYT(I) = CHAR_TEMP THEN
            DO;
               FIXL(P) = I;
               CNT(P)=0;  /* INITIALIZE SUBSCRIPT COUNT */
               TYPE(P) = VARIABLE;
               IF SYTYPE(I) = SPECIAL THEN FIXV(P) = SYDISP(I); /* BUILTIN FN */
               ELSE FIXV(P) = 0;
               REG(P),INX(P)=0; /* INITIALIZE REGISTER POINTERS */
               SYTCO(I) = SYTCO(I) + 1; /* COUNT REFERENCES */
               RETURN;
            END;
         I = PTR(I);
      END;
      FIXL(P) = -1;      /*  IDENTIFIER NOT  FOUND */
   END   ID_LOOKUP;


UNDECLARED_ID:
   PROCEDURE (P);
      /* ISSUES AN ERROR MESSAGE FOR UNDECLARED IDENTIFIERS AND
         ENTERS THEM WITH DEFAULT TYPE IN THE SYMBOL TABLE
      */
      DECLARE P FIXED BINARY (15);

      CALL ERROR('UNDECLARED IDENTIFIER:  ' || VAR(P) ,0);
      CALL EMITDATAWORD(0);
      Dummy = ENTER (VAR(P), FIXEDTYPE, DP-4, CARD_COUNT);
      CNT(P) = 0;
      FIXV(P) = 0;
      REG(P) = 0;
      INX(P) = 0;
      FIXL(P) = NDECSY;
      SYTCO(NDECSY) = 1;                /* COUNT FIRST REFERENCE */
      TYPE(P) = VARIABLE;
   END  UNDECLARED_ID;

SETINIT:
   PROCEDURE;
      /*  PLACES INITIAL VALUES INTO DATA AREA */
      DECLARE (I, J) FIXED BINARY (31);

      IF ITYPE = CHRTYPE THEN
         DO;
            IF TYPE(MPP1) ^= CHRTYPE THEN VAR(MPP1) = FIXV(MPP1);
            S = VAR(MPP1);    /* THE STRING */
            I = LENGTH(S) - 1;

            IF I < 0 THEN
               CALL EMITDESC(0);
            ELSE
               CALL EMITDESC(ISLL(I,24) + CHP);

            DO J = 0 TO I;
               CALL EMITCHAR(BYTE(S,J));
            END;
         END;
      ELSE IF TYPE(MPP1) ^= CONSTANT THEN
         CALL ERROR ('ILLEGAL CONSTANT IN INITIAL LIST');
      ELSE IF ITYPE = FIXEDTYPE THEN
         CALL EMITDATAWORD(FIXV(MPP1));
      ELSE IF ITYPE = HALFWORD THEN
         DO;
            /*  FIRST FORCE ALIGNMENT  */
            DP = IAND(DP, 1) + DP;
            CALL EMITBYTE (BIT(BINARY(IAND(ISRL(FIXV(MPP1), 8), 255), 8)));
/* IAND ADDED. */
            CALL EMITBYTE(BIT(BINARY(IAND(FIXV(MPP1), 255), 8)));
         END;
      ELSE IF ITYPE = BYTETYPE THEN
         CALL EMITBYTE(BIT(BINARY(FIXV(MPP1), 8)));
   END  SETINIT;

ALLOCATE :
   PROCEDURE(P,DIM);
      /* ALLOCATES STORAGE FOR THE IDENTIFIER AT P IN THE ANALYSIS
         STACK WITH DIMENSION DIM
      */

      DECLARE (P, DIM, J) FIXED BINARY (31);


   CHECK_NEWDP:
      PROCEDURE;
         DECLARE T FIXED BINARY (31);

         T = DP;
         DP = NEWDP;
         CALL CHECKBASES;
         DP = T;
      END  CHECK_NEWDP;



      DIM = DIM + 1;         /* ACTUAL NUMBER OF ITEMS  */
      SELECT (TYPE(P));

         WHEN (0) ;     /*  CASE  0    DUMMY        */

         WHEN (1)
         DO;      /*   CASE 1    HALFWORD  */
            NEWDP = IAND(NEWDP, 1) + NEWDP;  /* ALIGN HALFWORD */
            CALL CHECK_NEWDP;
            J = NEWDP;
            NEWDP = NEWDP + ISLL(DIM, 1);
         END;


         WHEN (2) ;     /*  CASE  2    LABEL TYPE         */


         WHEN (3) ;    /*  CASE  3    ACCUMULATOR        */

         WHEN (4) ;    /*  CASE  4    VARIABLE           */

         WHEN (5) ;    /*  CASE  5    CONSTANT           */

         WHEN (6) ;    /*  CASE  6    CONDITION          */

         WHEN (7)
          DO;  /*  CASE  7    CHARACTER TYPE     */
            IF NEWDSP>4095 THEN
               DO;
                  CALL ERROR('TOO MANY STRINGS', 1); NEWDSP=IAND(NEWDSP, "FFF"B4);
               END;
            J = -NEWDSP;
            NEWDSP = NEWDSP + ISLL(DIM,2);
          END;

         WHEN (8)
          DO;  /*  CASE  8    FIXED TYPE         */
            NEWDP = IAND(NEWDP + 3, "FFFFFC"B4);    /* ALIGN TO WORD */
            CALL CHECK_NEWDP;
            J = NEWDP;
            NEWDP = NEWDP + ISLL(DIM,2);
          END;

         WHEN (9)
          DO;  /*  CASE  9    BYTE TYPE          */
            CALL CHECK_NEWDP;
            J = NEWDP;
            NEWDP = NEWDP + DIM;
          END;

         WHEN (10)
         DO;  /*  CASE 10    FORWARD TYPE  (LABEL)  */
            NEWDP = IAND(NEWDP+3, "FFFFFC"B4);  /* WORD ALIGN */
            CALL CHECK_NEWDP;
            J = NEWDP;
            NEWDP = NEWDP + ISLL(DIM,2);        /* SPACE FOR FIXUPS  */
         END;

         WHEN (11) ;    /*  CASE 11    DESCRIPT           */

         WHEN (12) ;    /*  CASE 12    SPECIAL            */

         WHEN (13) ;    /*  CASE 13    FORWARD CALL       */

         WHEN (14) ;    /*  CASE 14    CHAR_PROC_TYPE             */

         WHEN (15) ;    /*  CASE 15    UNUSED             */

      END; /*  OF SELECT TYPE(P)  */

      SYTYPE(FIXL(P)) = TYPE(P);
      CALL FINDADDRESS(J);
      SYBASE(FIXL(P)) = BIT(BINARY(ADREG, 4));
      SYDISP(FIXL(P)) = BIT(BINARY(ADRDISP, 12));

   END  ALLOCATE;


TDECLARE:
   PROCEDURE (DIM);
      /*  ALLOCATES STORAGE FOR IDENTIFIERS IN DECLARATIONS  */
      DECLARE DIM FIXED BINARY (31);

      NEWDP = DP;
      NEWDSP = DSP;
      TYPE(MP) = TYPE(SP);
      CASEP = FIXL(MP);
      DO I = 1 TO INX(MP);
         FIXL(MP) = CASESTACK(CASEP+I);      /* SYMBOL TABLE POINTER */
         CALL ALLOCATE(MP, DIM);
      END;
   END  TDECLARE;




MOVESTACKS:
   PROCEDURE (F, T);
      DECLARE F FIXED BINARY (15), T FIXED BINARY (15);

      /*  MOVE ALL THE COMPILER STACKS DOWN FROM F TO T  */
      TYPE(T) = TYPE(F);  VAR(T) = VAR(F);
      FIXL(T) = FIXL(F);  FIXV(T) = FIXV(F);
      INX(T) = INX(F);    REG(T) = REG(F);
      PPSAVE(T) = PPSAVE(F);  CNT(T) = CNT(F);
   END  MOVESTACKS;




  /*                        BRANCH PROCEDURES                                */



BRANCH_BD:
   PROCEDURE(COND, B, D);
      DECLARE COND UNSIGNED FIXED BINARY(8), (B, D) FIXED BINARY (31);

      /*  BRANCHES ARE A SPECIAL CASE.  IF THEY ARE INTO THE 1ST  4096
         BYTES OF PROGRAM A SINGLE BRANCH WILL SUFFICE.  OTHERWISE WE
         MUST INDEX WITH A CONSTANT IN BRCHREG TO GET ANYWHERE.
      */
      IF B = 0 THEN
         CALL EMITRX(BC, COND, 0, PBR, D);
      ELSE
         DO;
            CALL EMITRX(LOAD,BRCHREG,0,DBR,ISLL(B,2));
            CALL EMITRX(BC, COND, BRCHREG, PBR, D);
         END;
   END  BRANCH_BD;


BRANCH:
   PROCEDURE (COND, LOCATION);
      DECLARE COND UNSIGNED FIXED BINARY(8), LOCATION FIXED BINARY (31);

      IF LOCATION = 0 THEN LOCATION = PP;
      /* ASSUME FIXUP WILL BE NEAR  */
      CALL BRANCH_BD(COND, ISRL(LOCATION,12), IAND(LOCATION, "00000FFF"B4));
   END BRANCH;




  /*                     EXPRESSIONS                                         */


CONDTOREG:
   PROCEDURE (MP, CC);
      DECLARE MP FIXED BINARY (15), CC UNSIGNED FIXED BINARY(8), J UNSIGNED FIXED BINARY(8);

      J = FINDAC();
      FIXL(MP)  = CC + ISLL(PP,4);  /* SAVE TILL THE END OF THIS PROCEDURE */
       /* SPECIAL CASES ARE SHORTER--NO BRANCH NEEDED */
      /* > AND < */
      IF (CC=12) | (CC=10) THEN
          DO;
            CALL EMITRR (BALR, J, 0, SOURCELINE() ); /* GET THE CONDITION CODE */
            CALL EMITRX("89"B4, J, 0, 0, 2+(CC=10));
            CALL EMITRX("88"B4, J, 0, 0, 31);
         END;
      ELSE
      DO;
         CALL EMITRX (LA, J, 0, 0, 1);
         IF PP<4088 THEN
            CALL BRANCH(14-CC, PP+6);
         ELSE
            DO;
               CALL EMITRR ("05"B4, BRCHREG, 0, SOURCELINE() );
               CALL EMITRX (BC, 14-CC, 0, BRCHREG, 6);
            END;
         CALL EMITRR("06"B4, J, 0, SOURCELINE() );
      END;
      STILLCOND = FIXL(MP);
      TYPE(MP) = ACCUMULATOR;
      REG(MP) = J;
   END CONDTOREG;

BRLINK_BD:
   PROCEDURE (BASE,DISP);
      DECLARE (BASE, DISP) FIXED BINARY (31);

      IF BASE = 0 THEN
         CALL EMITRX(BAL, BRCHREG, 0, PBR, DISP);
      ELSE
         DO;
            CALL EMITRX(LOAD, BRCHREG, 0, DBR, ISLL(BASE,2));
            CALL EMITRX(BAL, BRCHREG, BRCHREG, PBR, DISP);
         END;
   END  BRLINK_BD;


   /*                  CODE FOR PROCEDURES                                   */


SAVE_REGISTERS:
   PROCEDURE;
      /* GENERATES CODE TO SAVE REGISTERS BEFORE A PROCEDURE OR FUNCTION CALL */
      DECLARE I FIXED BINARY (16);

      DO I = 1 TO 3;
         IF BASES(I) ^= AVAIL THEN
            DO;
               CALL EMITDATAWORD(0);
               CALL FINDADDRESS(DP-4);
               TEMP(I) = ISLL(ADREG,12) + ADRDISP;
               CALL EMITRX(STORE, BIT(BINARY(I, 8)), 0, ADREG, ADRDISP);
            END;
         ELSE
            TEMP(I) = 0;
      END;
   END  SAVE_REGISTERS;


UNSAVE_REGISTERS:
   PROCEDURE (R,P);
      /*  GENERATES CODE TO RESTORE REGISTERS AFTER A FUNCTION
          OR PROCEDURE CALL AND ALSO DOES SOME HOUSEKEEPING
      */
      DECLARE R UNSIGNED FIXED BINARY(8), P FIXED BINARY (31);
      DECLARE (I, J) UNSIGNED FIXED BINARY(8);

      IF BASES(R) ^= AVAIL THEN
         DO;
            J = FINDAC();
            CALL EMITRR("18"B4, J, R, SOURCELINE() );
         END;
      ELSE
         J = R;
      DO I = 1 TO 3;
         IF TEMP(I) ^= 0 THEN
            CALL EMITRX(LOAD, I, 0, ISRL(TEMP(I),12), IAND(TEMP(I), "FFF"B4));
      END;
      TYPE(P) = ACCUMULATOR;
      REG(P) = J;
      BASES(J) = ACCUMULATOR;
   END  UNSAVE_REGISTERS;




CALLSUB:
   PROCEDURE (SB,SD, R, P);
      DECLARE (SB, SD, R, P) FIXED BINARY (31);

      CALL SAVE_REGISTERS;
      CALL BRLINK_BD(SB,SD);
      CALL UNSAVE_REGISTERS(R, P);
   END  CALLSUB;


CALLSUB_FORWARD:
   PROCEDURE (SB,SD,R,P);
      DECLARE (SB, SD, R, P) FIXED BINARY (31);

      CALL SAVE_REGISTERS;
      CALL EMITRX(LOAD, BRCHREG, 0, SB,SD);
      CALL EMITRX(BAL, BRCHREG, BRCHREG, PBR, 0);
      CALL UNSAVE_REGISTERS(R, P);
   END  CALLSUB_FORWARD;



FORCE_ADDRESS:
   PROCEDURE (SP, R);
      /* GENERATES THE ADDRESS OF THE <VARIABLE> IN THE ANALYSIS  */
      /* STACK AT SP IN REGISTER R.                               */

      DECLARE SP FIXED BINARY(15), K FIXED BINARY (31), (R, INXSP) UNSIGNED FIXED BINARY(8);

      IF SYTYPE(FIXL(SP)) = LABELTYPE THEN
         DO;
            K = FIXL(SP);
            IF SYBASE(K) = 0 THEN
               CALL EMITRX(LA,R,0,PBR,SYDISP(K));
            ELSE
               DO;
                  CALL EMITRX(LOAD,R,0,DBR,ISLL(SYBASE(K),2));
                  CALL EMITRX(LA,R,R,PBR,SYDISP(K));
               END;
         END;
      ELSE
         DO;
            K = SYTYPE(FIXL(SP));
            INXSP = INX(SP);
            IF INXSP ^= 0 THEN
               DO;
                  IF K ^= BYTETYPE THEN
                     IF K = HALFWORD THEN
                        CALL EMITRR ("1A"B4, INXSP, INXSP, SOURCELINE() );
                     ELSE
                        CALL EMITRX("89"B4,INXSP,0,0,2);
                  BASES(INXSP) = AVAIL;
               END;
            IF K = FORWARDTYPE | K = FORWARDCALL THEN
               DO;
                  K = FIXL(SP);
                  CALL EMITRX(LOAD,R,0,SYBASE(K),SYDISP(K));
                  CALL EMITRR("1A"B4, R, PBR, SOURCELINE() );
               END;
            ELSE
               CALL EMITRX(LA,R,INXSP,SYBASE(FIXL(SP)),SYDISP(FIXL(SP)));
         END;
   END  FORCE_ADDRESS;


FILE_PSEUDO_ARRAY:
   PROCEDURE (VARP,FILEP, DIRECTION);
      /* PROCEDURE TO GENERATE CODE FOR THE FILE PSEUDO ARRAY.
         TWO FORMS ARE HANDLED:

               <VARIABLE>  =  FILE(I,J);

               FILE(I,J)  =  <VARIABLE>;

         VARP IS A POINTER TO THE <VARIABLE> IN THE ANALYSIS STACKS.
         FILEP IS A POINTER TO THE ANALYSIS STACK WHERE FILE(I,J)
         HAS BEEN ASSIMILATED UNDER THE GUISE OF A SUBSCRIPTED
         VARIABLE.  DIRECTION = 0 FOR THE FIRST CASE (READ) AND
         DIRECTION = 4 FOR THE SECOND CASE (WRITE).  I IS THE FILE
         INDEX (I = 1,2,3) AND J IS THE RELATIVE RECORD WITHIN THE
         FILE.  THE GENERATED CODE SHOULD HAVE THE SAME EFFECT AS;

               LA   0,<VARIABLE>
               L    1,I
               SLL  1,3                 I*8
               LA   1,DIRECTION+44(,1)
               L    2,J
               BALR BRCHREG,IOREG

         REGISTERS 0-3 ARE NOT PRESERVED ACROSS THE MONITOR CALL,
         HENCE ALL REGISTERS ARE FREED,

      */
      DECLARE (VARP, DIRECTION, FILEP) FIXED BINARY (31);
      DECLARE R UNSIGNED FIXED BINARY(8);

      IF TYPE(VARP) = VARIABLE THEN
         DO;
            CALL FORCE_ADDRESS(VARP,0);
            CALL EMITRX("89"B4,REG(FILEP),0,0,3);   /*  I*8  */
            R = FINDAC();
            IF INX(FILEP) = '1'B4 THEN
               DO;                      /*  JUGGLE REGISTERS  */
                  CALL EMITRR("18"B4, R, 1, SOURCELINE() );
                  INX(FILEP) = BIT(BINARY(R, 8));
               END;
            CALL EMITRX(LA,1,0,REG(FILEP),44+DIRECTION);
            IF INX(FILEP) ^= 2 THEN
               CALL EMITRR("18"B4,2,INX(FILEP), SOURCELINE() );    /*  J    */
            CALL EMITRR(BALR, BRCHREG, IOREG, SOURCELINE() );
            TYPE(FILEP) = SPECIAL;      /*  NO MORE ASSIGNMENTS  */
            CALL CLEARREGS;            /*  FREE ALL REGISTERS  */
         END;
      ELSE
         CALL ERROR('ILLEGAL USE OF FILE PSEUDO ARRAY',1);
   END  FILE_PSEUDO_ARRAY;


EMIT_INLINE:
   PROCEDURE;

      /* GENERATES CODE FOR THE PSEUDO FUNCTION INLINE                */

      DECLARE BINLM CHARACTER(22) INITIAL ('BAD ARGUMENT TO INLINE');
      DECLARE (FV, FL) FIXED BINARY (31);

      FV = FIXV(MPP1);
      IF FV > 255 | FV < 0 THEN
         DO;
           CALL ERROR ('SUBSCRIPT ERROR IN EMIT_INLINE AT LINE ' || SOURCELINE() ||
               ', FV=' || FV, 0);
           FV = IAND(FV, 255);
         END;
      FL = FIXL(MPP1);
      IF CNT(MP) < 4 THEN
         DO;
            IF TYPE(MPP1) = CONSTANT THEN
               SELECT (CNT(MP));

                  WHEN (0) ;                              /* NO CASE 0 */

                  WHEN (1)
                  DO;
                     FIXL(MP) = FV;
                     INSTRUCT(FV) = INSTRUCT(FV) + 1; /* STATISTICS */
                  END;

                  WHEN (2)
                  DO;                            /* SAVE R1  */
                     TYPE(MP) = ACCUMULATOR;
                     REG(MP) = FIXV(MPP1);
                  END;

                  WHEN (3)
DO;
   PUT SKIP LIST (FIXL(MP), REG(MP), FIXV(MPP1));
                        CALL EMITCODEBYTES(BIT(BINARY(IAND(FIXL(MP), 255), 8)),
                        BIT(BINARY(IAND(ISLL(REG(MP), 4) + FIXV(MPP1), 255), 8)),
                        SOURCELINE() );
                                                 /* EMIT  OP R1 X  */
/* IAND PUT IN BOTH OF THE ABOVE LINES. */
END;
               END;
            ELSE
               CALL ERROR(BINLM,1);
         END;
      ELSE IF TYPE(MPP1) = CONSTANT THEN
         DO;
            IF IAND(CNT(MP), 1) ^= 0 THEN /* **************** MODIFIED **********/
               CALL EMITCODEBYTES(BIT(BINARY(INX(MP)+ISRL(FIXV(MPP1), 8), 8)),
                  BIT(BINARY(IAND(FIXV(MPP1), "FF"B4), 8)), SOURCELINE() );
                                       /* EMIT  B DDD  */
            ELSE
               INX(MP) = ISLL(FIXV(MPP1), 4);      /* SAVE BASE REG  */
         END;
      ELSE IF TYPE(MPP1) = VARIABLE THEN
         DO;
            CNT(MP) = CNT(MP) + 1;
            IF IAND(CNT(MP), 1) ^= 0 THEN   /**************** MODIFIED ************/
               DO;
                     IF SYTYPE(FL) = LABELTYPE THEN
                     DO;
                        IF SYBASE(FL)=0 THEN /* FIRST PAGE */
                           CALL EMITCODEBYTES(BIT(BINARY(IOR(ISLL(PBR,4), ISRL(SYDISP(FL),8)), 8)),
                              BIT(BINARY(SYDISP(FL), 8)), SOURCELINE() );
                           ELSE CALL ERROR(
                    'CANNOT USE INLINE WITH LABEL OUTSIDE PAGE 0', 1);
                        END;
                     ELSE
                        CALL EMITCODEBYTES(
                           BIT(BINARY(IOR(ISLL(SYBASE(FL),4), ISRL(SYDISP(FL),8)), 8)),
                           BIT(BINARY(SYDISP(FL), 8)), SOURCELINE() );
               END;
            ELSE
               CALL ERROR(BINLM, 1);
         END;
      ELSE
         CALL ERROR(BINLM, 1);

   END  EMIT_INLINE;




PROC_START:
   PROCEDURE;
      /*  GENERATES CODE FOR THE HEAD OF A PROCEDURE */
      DECLARE I FIXED BINARY (31);

      I = FIXL(MP);
      FIXL(MP) = PP;
      CALL BRANCH("F"B4,0);    /*  BRANCH AROUND  */
      CALL EMITDATAWORD(0);  /*  PLACE TO STORE RETURN ADDRESS */
      PPSAVE(MP) = RTNADR;
      RTNADR = DP - 4;
      CALL FINDADDRESS(RTNADR);
      SYBASE(I) = BIT(BINARY(ISRL(PP,12), 4));          /* ADDRESS OF THE PROCEDURE  */
      SYDISP(I) = BIT(BINARY(IAND(PP, "00000FFF"B4), 12));
      CALL EMITRX(STORE, BRCHREG,0,ADREG,ADRDISP);
   END  PROC_START;



CHECK_STRING_OVERFLOW:
   PROCEDURE;
      DECLARE (I, BR_SAVE) FIXED BINARY (31);

      ON SIZE BEGIN;
         PUT SKIP DATA(I, BR_SAVE, TSA);
         GO TO LAST;
      END;

      CALL EMITSS("D5"B4, 3, IOR(ISLL(DBR,12), TSA), IOR(ISLL(DBR,12), LIMITWORD)); /* CLC*/
      I = PP;
      CALL BRANCH (4, 0);
      CALL EMITDATAWORD(0);  BR_SAVE = DP - 4;
      CALL FINDADDRESS(BR_SAVE);
      CALL EMITRX(STORE, BRCHREG, 0, ADREG, ADRDISP);
      IF SYTYPE (STRING_RECOVER) = LABELTYPE THEN
         CALL CALLSUB(SYBASE(STRING_RECOVER),SYDISP(STRING_RECOVER), 0,
            STACKSIZE);
      ELSE
         CALL CALLSUB_FORWARD(SYBASE(STRING_RECOVER),
            SYDISP(STRING_RECOVER), 0, STACKSIZE);
      BASES(REG(STACKSIZE)) = AVAIL;
      CALL FINDADDRESS (BR_SAVE);
      CALL EMITRX(LOAD,BRCHREG,0,ADREG,ADRDISP);
      SYTCO(STRING_RECOVER) = SYTCO(STRING_RECOVER) + 1;
      CALL EMITRR ("1B"B4, 0, 0, SOURCELINE() );
      CALL FINDADDRESS (STRL);
      CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);
      CALL FIXBFW (I, PP);
LAST:
   END CHECK_STRING_OVERFLOW;


FORCEACCUMULATOR:
   PROCEDURE (P);
      DECLARE P FIXED BINARY (15);
      /* FORCE THE OPERAND AT P INTO AN ACCUMULATOR */
      DECLARE SD FIXED BINARY (31), R UNSIGNED FIXED BINARY(8),
         (SB, TP, SFP) BIT(8) ALIGNED, T1 CHARACTER (256) VARYING;
      DECLARE I FIXED BINARY (15);

      COUNT#FORCE = COUNT#FORCE + 1;
      TP = TYPE(P);
      IF TP = CONDITION THEN CALL CONDTOREG (P, REG(P));
      ELSE IF TP = VARIABLE THEN
         DO;
            SB = SYBASE(FIXL(P));
            SD = SYDISP(FIXL(P));
                IF INX(P)=16 THEN
                   DO; INX(P)=0; SD=SD+PPSAVE(P); END;
                 /* PPSAVE HAS SOME GOODIES TO INCREMENT THE DISPLACEMENT
                    WHEN THE SUBSCRIPT IS A CONSTANT */
            SFP = SYTYPE(FIXL(P));
            IF SFP = LABELTYPE | SFP = CHAR_PROC_TYPE THEN
               DO;
                  CALL CALLSUB(SB,SD,3,P);
                  IF LENGTH(SYT(FIXL(P)+CNT(P)+1)) = 0 THEN
                     IF CONTROL(BYTE('N')) THEN
                        PUT SKIP LIST ( '** WARNING--NOT ALL PARAMETERS SUPPLIED' );
                  IF SFP = CHAR_PROC_TYPE THEN
                     TYPE(P) = DESCRIPT;
               END;
            ELSE IF SFP = FORWARDTYPE | SFP = FORWARDCALL THEN
               DO;
                  CALL CALLSUB_FORWARD(SB,SD,3,P);
                  SYTYPE(FIXL(P)) = FORWARDCALL;
               END;
            ELSE  IF SFP = SPECIAL THEN
               DO;
                  CALL EMITRX("90"B4, 1, 3, DBR, IO_SAVE);
                  IF SD = 6 THEN
                     DO;  /*  INPUT */
                        CALL CHECK_STRING_OVERFLOW;
                        IF REG(P) = 0 THEN CALL EMITRR ("1B"B4, 2, 2, SOURCELINE() );
                        ELSE IF REG(P)^=2 THEN CALL EMITRR("18"B4, 2, REG(P), SOURCELINE() );
                        BASES(REG(P)) = AVAIL;
                        CALL FINDADDRESS (TSA);
                        CALL EMITRX("98"B4, 0, 1, ADREG, ADRDISP);
                        /* THIS IS A POINTER TO THE FIRST FREE STRING AREA*/
           /* SECOND WORD IS THE CONST. 4 FOR READ CARD. (SEE INITIALIZE)*/
                        CALL EMITRR (BALR, BRCHREG, IOREG, SOURCELINE() ); /* MONITOR CALL*/
                        /* MOVE FREE STRING AREA POINTER */
                        CALL EMITRX (STORE, 1, 0, ADREG, ADRDISP);
                        CALL FINDADDRESS (STRL);/* LAST COMPUTED STRING */
                        CALL EMITRX (STORE, 0, 0, ADREG, ADRDISP);
                        REG(P) = 0;
                        TYPE(P) = DESCRIPT;
                     END;
                  ELSE IF SD = 8 THEN
                     CALL FILE_PSEUDO_ARRAY(P-2,P,0);
                  ELSE IF SD >= 11 & SD <= 18 THEN
                     DO;
                        /* TRACE, UNTRACE, EXIT, TIME, DATE, ETC.         */
                        R = SD=15;
                        IF SD > 15 THEN
                           DO;
                              IF REG(P) ^= 0 THEN
                                 CALL EMITRR ("18"B4, 0, REG(P), SOURCELINE() );
                              BASES(REG(P)) = AVAIL;
                              IF INX(P) ^= 2 THEN
                                 CALL EMITRR ("18"B4, 2, INX(P), SOURCELINE() );
                              BASES(INX(P)) = AVAIL;
                           END;
                        /* SET UP MONITOR REQUEST CODE */
                        CALL EMITRX(LA,1,0,0,ISLL(SD-R,2)-32);
                        /* MONITOR CALL */
                        CALL EMITRR (BALR, BRCHREG, IOREG, SOURCELINE() );
                        TYPE(P) = ACCUMULATOR;
                        IF R ^= 0 THEN
                           CALL EMITRR ("18"B4, 0, R, SOURCELINE() );
                        REG(P) = 0;
                     END;
                  ELSE CALL ERROR (' ILLEGAL USE OF ' || SYT(FIXL(P)));
                  CALL EMITRX ("98"B4, 1, 3, DBR, IO_SAVE);
               END;
            ELSE
               DO;  /* FETCH THE VARIABLE (ALL ELSE HAS FAILED) */
                  I = SYBASE(FIXL(P));
                  IF SFP ^= BYTETYPE THEN
                     DO;
                        IF SFP = HALFWORD THEN TP="48"B4;
                        ELSE TP=LOAD;
                        R = INX(P);
                        IF R^=0 THEN
                          DO;
                           IF I=0 THEN /* FOR COREWORD, WE SPLIT THE SUBSCRIPT
                                          BETWEEN BASE & INDEX REGISTER */
                              DO;
                                 I = R;
                                 IF SFP=FIXEDTYPE THEN
                                 SFP = HALFWORD; /* A TRICK TO GET
                                                    AR  INX(P),INX(P) */
                                 ELSE IF SFP=HALFWORD THEN SFP=BYTETYPE;
                              END;
                           IF SFP = HALFWORD THEN
                           CALL EMITRR("1E"B4, R, R, SOURCELINE() ); /* ADD LOGICAL  AL R,R */
                           ELSE IF SFP^=BYTETYPE THEN
                           CALL EMITRX("89"B4, R, 0, 0, 2);
                           /* SHIFT INDEX FOR WORD-TYPE ARRAY */
                          END;
                        ELSE R = FINDAC();
                     END;
                  ELSE
                     DO;
                        IF IAND(BASES(1), BASES(2), BASES(3)) = ACCUMULATOR THEN
                           R=0; ELSE
                           DO;
                              R = FINDAC();
                              BASES(INX(P)) = AVAIL;
                           END;
                        CALL EMITRR("1F"B4, R, R, SOURCELINE() ); /* CLEAR R */
                        TP = "43"B4;
                        /* INSERT CHARACTER */
                     END;
                  CALL EMITRX(TP, R, INX(P), I, SD);
                        IF R=0 THEN /* TOO MANY ACCUMULATORS  BUT MAKE GOOD
                                       OBJECT CODE ANYHOW */
                     IF SFP=BYTETYPE THEN IF TARGET_REGISTER^=0 THEN
                           CALL EMITRR("18"B4, INX(P), 0, SOURCELINE() );
                  IF SFP = CHRTYPE THEN TYPE(P) = DESCRIPT;
                     ELSE TYPE(P) = ACCUMULATOR;
                  REG(P) = R;
               END;
         END;
            ELSE IF TP = CONSTANT THEN
               DO;
                  R = FINDAC();
                  /* FETCH A CONSTANT INTO AN ACCUMULATOR */
                  IF FIXV(P) = 0 THEN CALL EMITRR("1B"B4, R, R, SOURCELINE() );
                  ELSE IF FIXV(P) < "1000"B4 & FIXV(P) >= 1 THEN
                     CALL EMITRX(LA, R, 0, 0, FIXV(P));
                     ELSE
                        CALL LOAD_CONSTANT(LOAD, R, FIXV(P));
                  TYPE(P) = ACCUMULATOR;
                  REG(P) = R;
               END;
            ELSE IF TP = CHRTYPE THEN
               DO;
                  R = FINDAC();
                  TYPE(P) = DESCRIPT;
                  REG(P) = R;
                  T1 = VAR(P);
                  SD = LENGTH(T1) - 1;
                  IF SD < 0 THEN
                     CALL EMITRR("1B"B4, R, R, SOURCELINE() ); /* CLEAR  REG R, NULL STRING */
                  ELSE
                     IF SD = 0 THEN /* LENGTH=1 */
                         DO;
                            /* PLACE 1-BYTE CONSTANT STRINGS IN THE DATA AREA
                            & COMPUTE THE DESCRIPTOR, WHICH IS JUST THE ADDRESS,
                            AT EXECUTION TIME */
                            CALL FINDADDRESS(DP);
                            CALL EMITBYTE(BYTE(T1));
                            CALL EMITRX(LA, R, 0, ADREG, ADRDISP);
                         END;
                  ELSE
                     DO;
                        IF DSP> 3800 THEN /* WE ARE GETTING SHORT OF DESCRIPTR*/
                           DO; /* PLACE DESCRIPTOR IN DATA AREA */
                              CALL FINDADDRESS(DP);
                              CALL EMITRX(LA, R, 0, ADREG, ADRDISP);
                              DO I = 0 TO SD;
                                 CALL EMITBYTE(BYTE(T1, I));
                              END;
                              CALL EMITDATAWORD(ISLL(SD,24));
                              CALL FINDADDRESS(DP-4);
                              /* LOGICAL OR IN THE LENGTH */
                              TP = "56"B4;
                           END;
                        ELSE
                           DO;
                        CALL FINDADDRESS (-DSP);
                        /* MAKE UP A DESCRIPTOR */
                        CALL EMITDESC(ISLL(SD,24)+CHP);
                        DO I = 0 TO SD;
                           CALL EMITCHAR(BYTE(T1, I));
                        END;
                              TP = LOAD;
                           END;
                           CALL EMITRX(TP, R, 0, ADREG, ADRDISP);
                     END;
               END;
            ELSE IF TP ^= ACCUMULATOR THEN IF TP ^= DESCRIPT THEN
               CALL ERROR ('FORCEACCUMULATOR FAILED ***', 1);
   END FORCEACCUMULATOR;

STUFF_PARAMETER:
   PROCEDURE;
      /* GENERATES CODE TO SEND AN ACTUAL PARAMETER TO A PROCEDURE */
                  /* NO SPECIAL PROVISION FOR INX(MP)=16   REQUIRED */
         DECLARE I FIXED BINARY (15), J BIT(8) ALIGNED;

      I = FIXL(MP) + CNT(MP);
      J = '00'B4;
      IF TYPE(MPP1)=VARIABLE THEN
         IF INX(MPP1)=0 THEN
            IF SYTYPE(FIXL(MPP1))=SYTYPE(I) THEN J=1;
      IF LENGTH(SYT(I)) = 0 THEN
         DO;
          IF TYPE(MPP1)=CONSTANT & SYTYPE(I)=BYTETYPE THEN
            CALL EMITRX("92"B4, 0, FIXV(MPP1), SYBASE(I), SYDISP(I)); /* MVI */
            ELSE IF J ^= '00'B4 THEN
               DO; /* BOTH ARGUMENT & PARAMETER ARE SAME TYPE, SO EMIT MVC */
                  IF SYTYPE(I)=BYTETYPE THEN J='00'B; ELSE
                  IF SYTYPE(I)=HALFWORD THEN J='01'B4; ELSE J = '03'B4;
                  CALL EMITSS("D2"B4, J, IOR(ISLL(SYBASE(I), 12), SYDISP(I)),
                     IOR(ISLL(SYBASE(FIXL(MPP1)), 12), SYDISP(FIXL(MPP1))));
               END;
            ELSE
               DO;
                  CALL FORCEACCUMULATOR(MPP1);
                  IF SYTYPE(I)=BYTETYPE THEN
                    J="42"B4; /* STC */
                  ELSE IF SYTYPE(I)=HALFWORD THEN
                    J="40"B4; /* STH */
                  ELSE
                    J=STORE;/* ST  */
                  CALL EMITRX(J, REG(MPP1), 0, SYBASE(I), SYDISP(I));
                  BASES(REG(MPP1))=AVAIL;
               END;
         END;
      ELSE
         CALL ERROR('TOO MANY PARAMETERS', 1);
END STUFF_PARAMETER;

FORCEDESCRIPT:
   PROCEDURE (P);
      /* GET A DESCRIPTOR FOR THE OPERAND P */
      DECLARE P FIXED BINARY (15);

      CALL FORCEACCUMULATOR (P);
      IF TYPE(P) ^= DESCRIPT THEN
         DO;
            CALL EMITRX (STORE, REG(P), 0, DBR, STRN);
            /* STORE IN PARAMETER LOCATION FOR NUMBER-TO -DECIMAL-STRING */
            BASES(REG(P)) = AVAIL;
            CALL CALLSUB(0,NMBRNTRY,3,P);
            /* ASSUMES NUMBER-TO-STRING IS IN THE 1ST PAGE */
            TYPE(P) = DESCRIPT;
         END;
   END FORCEDESCRIPT;

GENSTORE:
   PROCEDURE (MP, SP);
      DECLARE (MP, SP, SD) FIXED BINARY (15), FLSP FIXED BINARY (31),
         (SFP, SB) UNSIGNED FIXED BINARY(8);
      DECLARE TP BIT(8) ALIGNED;
      DECLARE J UNSIGNED FIXED BINARY(8);

      FLSP = FIXL(SP);
      COUNT#STORE = COUNT#STORE + 1;
      IF TYPE(SP) = SPECIAL THEN RETURN;
      /* GENERATE TYPE CONVERSION (IF NECESSARY) & STORAGE CODE --
            ALSO HANDLES OUTPUT AND FILE ON LEFT OF REPLACE OPERATOR */
      SB = SYBASE(FIXL(MP));
      SD = SYDISP(FIXL(MP));
      SFP = SYTYPE(FIXL(MP));
      IF SFP = SPECIAL THEN
         DO;
            IF SD = 3 THEN      /*  FUNCTION BYTE ON THE LEFT */
               DO;
                  CALL FORCEACCUMULATOR(SP);
                  CALL EMITRX("42"B4, REG(SP), INX(MP), REG(MP), 0);
               END;
            ELSE IF SD = 7 THEN
               DO;      /* OUTPUT   */
                  IF PARSE_STACK(MP-1)=58 THEN
                     /* MULTIPLE ASSIGNMENT, SO SAVE REGISTERS */
                  CALL EMITRX("90"B4,1,3,DBR,IO_SAVE);
                  TARGET_REGISTER = 0;
                  CALL FORCEDESCRIPT (SP);
                  TARGET_REGISTER = -1;
                  IF REG(SP) ^= 0 THEN CALL EMITRR ("18"B4, 0, REG(SP), SOURCELINE() );
                  IF REG(MP) = 0 THEN CALL EMITRR ("1B"B4, 2, 2, SOURCELINE() );
                  ELSE IF REG(MP) ^= 2 THEN CALL EMITRR ("18"B4, 2, REG(MP), SOURCELINE() );
                  BASES(REG(MP)) = AVAIL;
                  CALL EMITRX (LA, '1'B4, '0'B4, '0'B4, 8);  /* 8 = PRINT CODE */
                  CALL EMITRR (BALR, BRCHREG, IOREG, SOURCELINE() ); /* MONITOR CALL */
                  IF PARSE_STACK(MP-1)=58 THEN
                  CALL EMITRX("98"B4, '1'B4, '3'B4, DBR,IO_SAVE);
               END;
            ELSE IF SD = 8 THEN
               CALL FILE_PSEUDO_ARRAY(SP,MP,4);
            ELSE CALL ERROR ('ILLEGAL USE OF ' || SYT(FIXL(MP)));
         END;
      ELSE
         DO;
            /* CODE ECONOMISER FOR SIMPLE ASSIGNMENTS;
               IDENTIFIER=IDENTIFIER, AND IDENTIFIER(SUBSCRIPT)=IDENTIFIER.
               THE FORMER FOR ALL TYPES, THE LATTER FOR BYTE TYPE ONLY */
            I = INX(MP);
            IF I=16 THEN I,INX(MP)=0; ELSE PPSAVE(MP)=0;
            IF INX(SP)=16 THEN INX(SP)=0; ELSE PPSAVE(SP)=0;
            SD = SD + PPSAVE(MP); /* A CORRECTION DUE TO CONSTANT SUBSCRIPT */
            J = '00'B4;
            IF TYPE(SP)=VARIABLE THEN IF INX(SP) =0 THEN
               IF SYTYPE(FLSP)=SFP THEN
                 IF (SFP=BYTETYPE) | (SFP=HALFWORD & I=0) |
                    (SFP=FIXEDTYPE & I = 0) | (SFP=CHRTYPE & I=0) THEN
                       J = '1'B4; /* SET ECONOMISER BIT */
            IF PARSE_STACK(MP-1)=58 /* LEFT PART -> WE HAVE MULTIPLE ASSIGNMENT
                                    */ THEN J=0; /* SO NO ECONOMISING */
               ELSE
                  IF TYPE(SP)=VARIABLE THEN IF SFP=BYTETYPE THEN
                     IF SYTYPE(FLSP)=SFP THEN IF INX(SP)^=0 THEN
                        DO;
                           /* NO NEED TO CLEAR REG(SP) FOR THE IC */
                           REG(SP)=INX(SP);
                           CALL EMITRX("43"B4, REG(SP), REG(SP), SYBASE(FLSP),
                                 SYDISP(FLSP) + PPSAVE(SP));
                           TYPE(SP) = ACCUMULATOR;
                           J = '0'B4;
                        END;
            IF J = 1 THEN /********************** MODIFIED ***************/
               DO;
                  J = INX(MP);
                  IF SB>0 THEN /* EXCEPT FOR COREBYTE */
                  IF J ^= '0'B THEN
                        /* ONLY FOR BYTE TYPE */
                       CALL EMITRR("1E"B4, J, SB, SOURCELINE() );     /* CODE FOR SUBSCRIPT */
                  ELSE
                     J=SB;
                  I = 3;
                  IF SFP=BYTETYPE THEN
                     I=0;
                  ELSE IF SFP=HALFWORD THEN
                     I=1;
                  CALL EMITSS("D2"B4, BIT(BINARY(I, 8)), IOR(ISLL(J,12), SD),
                    IOR(ISLL(SYBASE(FLSP), 12), SYDISP(FLSP)));
                  REG(SP) = 0;
               END;
            ELSE
            IF SFP=BYTETYPE & TYPE(SP)=CONSTANT THEN
               DO;
            /* SUBSCRIPTED & SCALAR BYTETYPE VARIABLES ASSIGNED TO A CONSTANT */
                  IF INX(MP)^=0 THEN
                    DO;
                       IF SB>0 THEN /* EXCEPT FOR COREBYTE, COREWORD */
                       CALL EMITRR("1E"B4, INX(MP), SB, SOURCELINE() );
                       SB = INX(MP);
                    END;
                  CALL EMITRX("92"B4, 0, FIXV(SP), SB, (SD)); /* MVI */
                  REG(SP) = 0; /* INITIALIZE FOR BASES(REG(SP))=AVAIL LATER */
               END;
            ELSE
             DO;
            CALL FORCEACCUMULATOR (SP);
            IF TYPE(SP) ^= SPECIAL THEN
               DO;
                  IF SFP=FIXEDTYPE & TYPE(SP)=ACCUMULATOR | SFP=CHRTYPE THEN
                     DO;
                        IF SFP = CHRTYPE THEN CALL FORCEDESCRIPT (SP);
                        /* SHIFT INDEX FOR WORD ARRAY */
                        IF INX(MP) ^= '0'B4 THEN
                        /* FOR COREWORD, SPLIT INDEX OVER BASE & INDEX FIELDS */
                           IF SB = 0 THEN
                              DO; SB = INX(MP); CALL EMITRR("1E"B4, SB, SB, SOURCELINE() ); END ;
                           ELSE CALL EMITRX("89"B4, INX(MP), 0, 0, 2);
                        TP = STORE;
                     END;
                  ELSE IF SFP = HALFWORD & TYPE(SP) = ACCUMULATOR THEN
                     DO;
                        IF SB = 0 THEN SB = INX(MP); ELSE
                        /* FOR COREHALFWORD, SPLIT INDEX OVER BASE & INDEX FIELD. */
                        IF INX(MP) ^= 0 THEN CALL EMITRR("1E"B4, INX(MP),INX(MP), SOURCELINE() );
                        TP = "40"B4; /* STH */
                     END;
                  ELSE IF SFP = BYTETYPE & TYPE(SP) = ACCUMULATOR THEN
                        TP = "42"B4; /* STC */
                  ELSE CALL ERROR('ASSIGNMENT NEEDS ILLEGAL TYPE CONVERSION');
                  CALL EMITRX(TP, REG(SP), INX(MP), SB, (SD));
               END;
            END;
         END;
      BASES(INX(MP)) = AVAIL;
      BASES(REG(SP)) = AVAIL;
      CALL MOVESTACKS (SP, MP);
   END GENSTORE;

STRINGCOMPARE:
   PROCEDURE;
      /* GENERATES THE CODE TO COMPARE THE STRINGS AT SP & MP */
      DECLARE (I, J, K) FIXED BINARY (31);
      DECLARE TYPESAVE BIT(8) ALIGNED, LENGTHCON FIXED BINARY (15);

      TYPESAVE =  TYPE(SP);
      IF TYPESAVE=CHRTYPE THEN
         DO;
            LENGTHCON = LENGTH(VAR(SP)) - 1;
            IF LENGTHCON<0 THEN /* WE ARE LOOKING FOR A NULL STRING */
               DO;
                  CALL EMITRR("12"B4, REG(MP), REG(MP), SOURCELINE() ); /* LTR */
                  RETURN; /* NO NEED TO MAKE BASES(REG(SP)) AVAILABLE SINCE
                               NOT USED */
               END;
         END;
      CALL FORCEDESCRIPT (SP);  /* GET THE DESCRIPTOR FOR THE SECOND OPERAND */
      CALL EMITRR ("18"B4, 0, REG(MP), SOURCELINE() );  /* WE CAN USE 0 FOR SCRATCH */
      CALL EMITRR ("17"B4, 0, REG(SP), SOURCELINE() );     /* EXCL. | TO COMPARE  */
      CALL EMITRX ("8A"B4, 0, 0, 0, 24);  /* CHECK HIGH ORDER 8 BITS FOR ZERO */
      IF REG(MPP1) = '06'B4 | REG(MPP1) = '08'B4 THEN
         DO;          /* IF WE ONLY NEED TO TEST EQUALITY, CODE IS SIMPLER  */
            K = PP;
            CALL BRANCH (6, 0);
         END;
      ELSE
         DO;
            J = PP;
            CALL BRANCH (8, 0);     /*  SKIP IF EQUAL LENGTH */
            CALL EMITRR ("15"B4, REG(MP), REG(SP), SOURCELINE() );     /* SET CONDITION CODE  */
            K = PP;  /* SAVE FOR FIXUP */
            CALL BRANCH ("F"B4, 0);  /* BRANCH AROUND STRING COMPARE CODE  */
            CALL FIXBFW (J, PP);
         END;
      /* TEST FOR NULL STRINGS. IF ONE OPERAND IS NULL, CAN'T DO CLC */
      CALL EMITRR ("12"B4, 0, REG(MP), SOURCELINE() );       /* LTR  0,REG(MP) */
      J = PP; CALL BRANCH ("6"B4, 0); /* BNE BRANCH AROUND NULL STRING CODE */
      M = PP; /* FOR A BRANCH IN CASE OF NULL STRINGS */
      CALL EMITRR ("15"B4, REG(MP), REG(SP), SOURCELINE() ); /* CLR SET CONDITION CODE */
      L = PP; CALL BRANCH("F"B4, 0);          /* EXIT BRANCH */
      CALL FIXBFW (J, PP);
      IF TYPESAVE^=CHRTYPE THEN /* MORE CODE WHEN BOTH OPERANDS ARE VARIABLES */
         DO;
            CALL EMITRR ("12"B4, 0, REG(SP), SOURCELINE() );
            CALL BRANCH ("8"B4, M); /* BZ: BRANCH TO THE NULL STRING CODE */
         END;
      /* NOW COMPARE THE STRINGS */
      IF TYPESAVE=CHRTYPE THEN
         CALL EMITSS("D5"B4, BIT(BINARY(LENGTHCON, 8)), ISLL(REG(MP), 12), ISLL(REG(SP), 12));
      ELSE
         DO; /* USE REG 12, THE BRANCH REGISTER, AS A TEMPORARY */
            CALL EMITRR("18"B4, BRCHREG, REG(MP), SOURCELINE() );
            CALL EMITRX("88"B4, BRCHREG, 0, 0, 24);
            DP = IAND(DP, 1) + DP;       /* ALIGN ON A HALFWORD BOUNDARY */
            CALL FINDADDRESS(DP);
            INSTRUCT("D5"B4) = INSTRUCT("D5"B4) + 1;
            CALL EMITBYTE("D5"B4);
            CALL EMITBYTE(0);
            CALL EMITBYTE(BIT(BINARY(ISLL(REG(MP), 4), 8)));
            CALL EMITBYTE(0);
            CALL EMITBYTE (BIT(BINARY(ISLL(REG(SP), 4), 8)));
            CALL EMITBYTE (0);
            CALL EMITRX("44"B4, BRCHREG, 0, ADREG,ADRDISP);
         END;
      BASES(REG(SP)) = AVAIL;
      CALL FIXBFW (L, PP);  /* NULL STRINGS RESUME HERE */
      CALL FIXBFW (K, PP);  /* BRING OTHER BRANCH IN HERE */
   END STRINGCOMPARE;

SHOULDCOMMUTE:
   PROCEDURE RETURNS (BIT(1) ALIGNED);
      IF TYPE(MP)=ACCUMULATOR THEN RETURN (FALSE);
      IF TYPE(MP)=VARIABLE THEN IF SYTYPE(FIXL(MP))=BYTETYPE THEN RETURN (FALSE);
      IF TYPE(SP)=ACCUMULATOR THEN RETURN (TRUE);
      IF TYPE(SP)=CONSTANT THEN RETURN (TRUE);
      IF TYPE(SP)=VARIABLE THEN IF SYTYPE(FIXL(SP))=BYTETYPE THEN RETURN (TRUE);
      RETURN (FALSE);
   END SHOULDCOMMUTE;

ARITHEMIT:
   PROCEDURE (OP);
      /* EMIT AN INSTRUCTION FOR AN INFIX OPERATOR -- CONNECTS MP & SP */
      DECLARE OP BIT(8) ALIGNED, (T1, T2) UNSIGNED FIXED BINARY(8), TP FIXED BINARY (31),
         EXCHANGECC(0:15) UNSIGNED FIXED BINARY(8) STATIC INITIAL
         (0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15);

      COUNT#ARITH = COUNT#ARITH + 1;
      TP = 0;  /* REMEMBER IF COMMUTED */
      IF COMMUTATIVE(OP) THEN
            IF SHOULDCOMMUTE() THEN
               DO;
                  IF OP=CMPRR THEN
                    DO;
                       /* COMPARISON OPERATIONS ARE COMMUTATIVE.  HOWEVER
                          THE OPERATOR MAY HAVE TO BE CHANGED.
                          = AND ^= CODES REMAIN UNCHANGED.
                          WE CHANGE THE FOLLOWING RELATION OPERATORS:
                          > BECOMES <
                          < BECOMES >
                          >=BECOMES <=
                          <=BECOMES >=
                          ^>BECOMES >=
                          ^<BECOMES <=
                                                        */
                       /* REPLACE CONDITION MASK */
                       REG(MPP1) = EXCHANGECC(REG(MPP1));
                    END;
                  TP = MP; MP = SP; SP = TP;
               END;
      CALL FORCEACCUMULATOR (MP);  /* GET THE LEFT ONE INTO AN ACCUMULATOR */
      /* FIXL(SP) IS GARBAGE IF TYPE ^= VARIABLE, WE GET 0C5 IF WE TEST IT */
      T1 = "00"B4;
      IF TYPE(SP) = VARIABLE THEN IF SYTYPE(FIXL(SP)) = FIXEDTYPE THEN T1 = "01"B4;
                                  ELSE IF SYTYPE(FIXL(SP))=HALFWORD THEN
                                  IF OP>=CMPRR & OP<="1C"B4 THEN T1='02'B4;
      IF TYPE(MP) = DESCRIPT THEN
         DO;
            IF OP = CMPRR THEN CALL STRINGCOMPARE;
            ELSE CALL ERROR ('ARITHMETIC WITH A STRING DESCRIPTOR');
         END;
      ELSE IF T1>0 THEN
            DO; /* OPERATE DIRECTLY FROM STORAGE:   CH,  AH,  SH and MH
                                         OPCODES   "49","4A","4B","4C"
                                         & ALL FULLWORD OPCODES               */
               T2 = INX(SP);
               IF T2 = 16 THEN /* 16 is a special case. */
                  T2,INX(MP)=0;
               ELSE
                  PPSAVE(SP)=0;
               IF T2^=0 THEN IF IAND(T1, 1) ^= 0 THEN /*********** MODIFIED *********/
                                      CALL EMITRX("89"B4, T2, 0, 0, 2); /*FULLWORD*/
                                   ELSE
                                      CALL EMITRR("1A"B4, T2, T2, SOURCELINE() ); /*HALFWORD*/
               /* OP + 64 GIVES THE FULLWORD OPERATION CODE */
               /* OP + 48 GIVES THE HALFWORD OPERATION CODE */
               IF T1=2 THEN
                  DO;
                     IF OP="1C"B4 THEN REG(MP) = BIT(BINARY(REG(MP)+1, 8)); /* FOR MH */
                     OP = BIT(BINARY(OP - 16, 8));  /* CH,AH,SH,MH */
                  END;
               CALL EMITRX(BIT(BINARY(OP + 64, 8)), REG(MP), T2, SYBASE(FIXL(SP)),
                  SYDISP(FIXL(SP))+PPSAVE(SP));
               BASES(T2) = AVAIL;
            END;
      ELSE IF TYPE(SP) = CONSTANT THEN
            DO;
               IF OP = CMPRR & SAVEADR ^= 0 THEN
                  DO; /* ERASE GENERATED CODE FOR LENGTH */
                     IF CONTROL(BYTE('E')) THEN
                        PUT SKIP LIST( 'WHOA: Back up the code emitter.' );
                     IF FIXV(SP)=0 THEN
                        DO ; /* RESET PP */
                           PP = LENGTHPP2;
                           CALL EMITRR("12"B4, 0, REG(MP), SOURCELINE() ); /* LTR */
                        END;
                     ELSE
                        DO;
                           PP = LENGTHPP; /* RESET PROGRAM POINTER */
                           T2 = IAND(ISRL(SAVEADR, 16), "0F"B4); /* UNPACK INDEX */
                           IF T2 ^= 0 THEN
                              DO; /* SHIFT TO WORD INDEXING */
                                 CALL EMITRX("89"B4, T2, 0, 0, 2);
                                 CALL EMITRR("1E"B4, T2, SBR, SOURCELINE() );
                                 SAVEADR = IAND(SAVEADR, "00000FFF"B4);
                              END;
                           CALL EMITRX ("95"B4, 0, FIXV(SP)-1, T2, SAVEADR);
                           BASES(REG(MP)) = AVAIL;
                           REG(MP) = EXCHANGECC(REG(MP));
                        END;
                  END;
               ELSE
                  DO;
             IF OP="1B"B4 & FIXV(SP)=1 THEN
               CALL EMITRR ("06"B4, REG(MP), 0, SOURCELINE() );
            ELSE
                           CALL LOAD_CONSTANT(BIT(BINARY(OP+64, 8)), REG(MP), FIXV(SP));
                        END;
             END;
      ELSE
            DO;
               CALL FORCEACCUMULATOR (SP);
               IF TYPE(SP) ^= ACCUMULATOR THEN
                  CALL ERROR ('ARITHMETIC BETWEEN STRING DESCRIPTORS', 1);
               CALL EMITRR (OP, REG(MP), REG(SP), SOURCELINE() );
               BASES(REG(SP)) = AVAIL;
            END;
      IF TP ^= 0 THEN
         DO;  /* COMMUTED */
            SP = MP;  MP = TP;
            CALL MOVESTACKS (SP, MP);
         END;
         /* BY THE ALGORITHM, TYPE(MP) IS ALREADY ACCUMULATOR */
   END ARITHEMIT;

BOOLBRANCH:
   PROCEDURE (SP, MP);
      DECLARE (SP, MP) FIXED BINARY (15), T1 BIT(1) ALIGNED;

      T1 = "0"B;
      IF TYPE(SP) = VARIABLE THEN IF SYTYPE(FIXL(SP)) = BYTETYPE THEN T1 = "1"B;
      /* GENERATE A CONDITIONAL BRANCH FOR A DO WHILE OR AN IF STATEMENT */
      IF STILLCOND ^= 0 THEN
         DO;
            BASES(REG(SP)) = AVAIL;
            PP = ISRL(STILLCOND, 4);     /* RESET THE PROGRAM POINTER */
            IF CONTROL(BYTE('E')) THEN
               PUT SKIP EDIT( 'BACK UP CODE EMITTER' )(COL(80), A);
            INSTRUCT(BC) = INSTRUCT(BC) - 1;  /* KEEP STATISTICS ACCURATE */
            INSTRUCT(LA) = INSTRUCT(LA) - 1;
            INSTRUCT(6) = INSTRUCT(6) - 1; /* BCTR */
            REG(SP) = BIT(BINARY(IAND(STILLCOND, "0000000F"B4), 8));
         END;
      ELSE IF T1 THEN
         DO;
            I = SYBASE(FIXL(SP)); J = SYDISP(FIXL(SP));
            IF INX(SP)='10'B4 THEN /* THE SUBSCRIPT WAS A CONSTANT */
               DO; J = J + PPSAVE(SP); INX(SP)=0; END;
            IF INX(SP) ^= 0 THEN
               DO;
                  IF I>0 THEN /* EXCEPT FOR COREBYTE */
                     CALL EMITRR ("1E"B4, INX(SP), BIT(BINARY(I, 8)), SOURCELINE() );
                  I = INX(SP);
                  BASES(INX(SP)) = AVAIL;
               END;
            CALL EMITRX ("91"B4, 0, 1, BIT(BINARY(I, 8)), J);
                  /*  TEST UNDER MASK  */
            REG(SP) = '08'B4;
         END;
      ELSE IF TYPE(SP) = CONSTANT THEN
         DO;
            IF IAND(FIXV(SP), 1) ^= 0 THEN /**************** MODIFIED ************/
               DO;  FIXL(MP) = 0;  RETURN; END;
            ELSE REG(SP) = '0F'B4;
         END;
      ELSE IF TYPE(SP) ^= CONDITION THEN
         DO;
            CALL FORCEACCUMULATOR (SP);
            CALL EMITRX ("54"B4, REG(SP), 0, DBR, TRUELOC);/* TEST LS BIT */
            BASES(REG(SP)) = AVAIL;
            REG(SP) = '08'B4;
         END;
      FIXL(MP) = PP;  /* SAVE ADDRESS FOR FUTURE FIXUP */
      CALL BRANCH (REG(SP), 0);  /* REG(SP) HAS THE CC TO BE TESTED FOR */
   END BOOLBRANCH;


SET_LIMIT:
   PROCEDURE(MPP1);
      /*  SETS DO LOOP LIMIT FOR <ITERATION CONTROL>   */
      DECLARE MPP1 FIXED BINARY (15);

      IF TYPE(MPP1) = CONSTANT THEN
         CALL EMITCONSTANT(FIXV(MPP1));
      ELSE
         DO;
            CALL FORCEACCUMULATOR(MPP1);
            CALL EMITDATAWORD(0);
            CALL FINDADDRESS(DP-4);
            CALL EMITRX(STORE,REG(MPP1),0,ADREG,ADRDISP);
            BASES(REG(MPP1)) = AVAIL;
         END;
   END  SET_LIMIT;


DIVIDE_CODE:
   PROCEDURE(DIV); /* GENERATES CODE FOR DIVISION AND MOD */
      DECLARE DIV BIT(8) ALIGNED;
      DECLARE (I,J,K) UNSIGNED FIXED BINARY(8);

      TARGET_REGISTER=0;
      IF(BASES(2)=AVAIL) & (BASES(3)=AVAIL) THEN TARGET_REGISTER=2;
      CALL FORCEACCUMULATOR(MP); /* FETCH DIVIDEND IF NOT ALREADY IN REGISTER */
      TARGET_REGISTER=-1;
      I=REG(MP);
      IF IAND(I, 1) ^= 0 THEN /******************** MODIFIED **********/
        DO; /* WE HAVE AN ODD-NUMBERED REGISTER */
           CALL EMITRR("18"B4, 0, I, SOURCELINE() );   /* LR  0,REG(MP)  */
           BASES(I)=AVAIL;
           REG(MP),
           I=0;
        END;
      J=0; K = I+1; /* K IS THE NEXT ODD-NUMBERED REGISTER */
      IF BASES(K)^=AVAIL THEN
        DO; /* NEXT ODD-NUMBERED REGISTER IS NOT AVAILABLE, SO SAVE ITS CONTENT*/
           J = FINDAC(); /* FIND A SPARE ACCUMULATOR */
           CALL EMITRR("18"B4, J, K, SOURCELINE() );  /* LR  J,REG(MP)+1   SAVE REGISTER */
           /* BEWARE IF THE REGISTER WE ARE SHIFTING IS THE SECOND OPERAND,SP,
              OR ITS SUBSCRIPT */
           IF TYPE(SP)=VARIABLE THEN IF INX(SP)=K THEN INX(SP)=J;
           IF TYPE(SP)=ACCUMULATOR THEN IF REG(SP)=K THEN REG(SP)=J;
        END;
      CALL EMITRX("8E"B4, I, 0, 0, 32); /* SRDA REG(MP),32(0,0) SMEAR THE SIGN */
      BASES(K)=ACCUMULATOR;
      CALL ARITHEMIT("1D"B4); /* DIVIDE */
      BASES(I), BASES(K)=AVAIL;
      IF J>0 THEN
        DO; /* ORIGINAL ODD REGISTER WAS NOT AVAILABLE */  /*********** NEXT LINE MODIFIED */
           IF (DIV & '01'B4) ^= '0'B THEN CALL EMITRR("18"B4, I, K, SOURCELINE() );
                                          /* GET RESULT IN EVEN REGISTER*/
           IF REG(SP)^=J THEN
              DO; /* RESTORE THE SECOND REG, EXCEPT IF IT WAS OPERAND SP */
                 CALL EMITRR("18"B4, K, J, SOURCELINE() );
                 BASES(J)=AVAIL;
                 BASES(K)=ACCUMULATOR;
              END;
        END;
       ELSE /* ORIGINAL ODD REGISTER WAS AVAILABLE */ /***************NEXT LINE MODIFIED ***/
         IF (DIV & '01'B4) ^= '0'B THEN I=K; /* RESULT IN ODD REGISTER FOR DIVISION */
      IF  I=0 THEN
        DO;   /* GET RESULT IN REGISTERS 1,2,OR 3 */
             I=FINDAC();
             CALL EMITRR("18"B4, I, 0, SOURCELINE() );
        END;
       ELSE  BASES(I)=ACCUMULATOR; /* RESERVE REGISTER CONTAINING RESULT */
      REG(MP)=I; /* WHERE TO FIND RESULT */

   END  DIVIDE_CODE;


SHIFT_CODE:
   PROCEDURE (OP);
      /*  GENERATES CODE FOR THE BUILT IN FUNCTIONS  SHL  AND  SHR  */
      DECLARE OP BIT (8) ALIGNED;

      IF CNT(MP) ^= 2 THEN
         CALL ERROR('SHIFT REQUIRES TWO ARGUMENTS',0);
      ELSE IF TYPE(MPP1) = CONSTANT THEN
         DO;
            IF OP = "89"B4 & FIXV(MPP1) = 1 THEN
               CALL EMITRR ("1A"B4, REG(MP), REG(MP), SOURCELINE() );
            ELSE CALL EMITRX (OP, REG(MP), 0, 0, FIXV(MPP1));
         END;
      ELSE
         DO;
            CALL FORCEACCUMULATOR(MPP1);
            CALL EMITRX(OP, REG(MP), 0, REG(MPP1), 0);
            BASES(REG(MPP1)) = AVAIL;
         END;
      TYPE(MP) = ACCUMULATOR;
   END  SHIFT_CODE;



  /*                    BUILT-IN FUNCTIONS                              */


REGISTER_SETUP_CODE:
   PROCEDURE;
      CALL EMITRR("18"B4, PBR, '2'B4, SOURCELINE() );  /* SET BASE */
      CALL EMITRR("18"B4, DBR, '3'B4, SOURCELINE() );
      CALL EMITRX(STORE,BRCHREG, 0, DBR, BIT(BINARY(RTNADR, 12)));
      CALL EMITCONSTANT (256);
      CALL EMITRX ("5B"B4, '1'B4, 0, ADREG, BIT(BINARY(ADRDISP, 12)));
      LIMITWORD = DP;
      CALL EMITRX (STORE, '1'B4, 0, DBR, DP);
      I = ENTER ('FREELIMIT', FIXEDTYPE, DP, 0); /* Discard returned value. */
      CALL EMITDATAWORD (0);
      CALL EMITRX(STORE, 0, 0, DBR, DP);
      I = ENTER('PARMSTRING', CHRTYPE, DP, 0); /* Discard returned value. */
      CALL EMITDATAWORD(0);
      BASEDATA = DP;
      DP = DP+16;
      CALL EMITRX ("98"B4, '4'B4, DBR-1, DBR, DP);  /* LOAD MULTIPLE  */
      DO I = 4 TO DBR-1;
         CALL EMITRR("1A"B4, I, DBR, SOURCELINE() );
      END;
      DP = DP + ISLL(DBR-4, 2);
   END REGISTER_SETUP_CODE;

RELOCATE_DESCRIPTORS_CODE:
   PROCEDURE;
      /* EMIT CODE TO RELOCATE DESCRIPTORS TO ABSOLUTE ADDRESSES */

      CALL EMITRX(LOAD,0,0,DBR,BASEDATA+8);
      CALL EMITRR("1A"B4, 0, DBR, SOURCELINE() );
      CALL EMITRX(STORE,0,0,DBR,TSA);
      CALL EMITRX (STORE, 0, 0, DBR, DP);
      I = ENTER ('FREEBASE', FIXEDTYPE, DP, 0); /* Discard returned value. */
      CALL EMITDATAWORD (0);
      CALL EMITRX("91"B4, 0, '1'B4, DBR, BASEDATA+12);
      K = PP;
      CALL BRANCH (1, 0);
      CALL EMITRX("96"B4, 0, 1, DBR, BASEDATA+12);
      CALL EMITRX(LOAD, '1'B4, 0, DBR, BASEDATA);
      CALL EMITRX (LA, SBR, '1'B4, DBR, 0);
      CALL EMITRX(LOAD, '2'B4, 0, DBR, BASEDATA+4);
      CALL EMITRR ("1A"B4, '2'B4, DBR, SOURCELINE() );
      J = PP;                             /* SAVE DESTINATION FOR LOOP */
      CALL EMITRX (LOAD,'3'B4, 1, DBR, 0);
      CALL EMITRR ("12"B4, '3'B4, '3'B4, SOURCELINE() );
      CALL BRANCH (8,PP+10);              /* ESCAPE */
      CALL EMITRR ("1A"B4, '3'B4, '2'B4, SOURCELINE() );
      CALL EMITRX (STORE, '3'B4, '1'B4, DBR, 0);
      CALL EMITRX (LA, '1'B4, '0'B4, '1'B4, 4);
      CALL EMITRX(CMPR, '1'B4, 0, DBR, BASEDATA+4);
      CALL BRANCH (4,J);                  /* LOOP */
      CALL FIXBFW (K,PP);
      CALL BRANCH (15,0);      /*  JUMP TO FIRST COMPILED CODE */
   END RELOCATE_DESCRIPTORS_CODE;

CATENATE_CODE:
   PROCEDURE;
      /* BUILD A CATENATE SUBROUTINE  */

      CATENTRY = PP;
      CALL CHECK_STRING_OVERFLOW;
      CALL EMITRX (LOAD, '1'B4, 0, A1, A2);  /*  LOAD FIRST DESCRIPTOR */
      CALL EMITRR ("18"B4, '3'B4, '1'B4, SOURCELINE() );  /* COPY INTO REG(3)  */
      CALL EMITRX ("5E"B4, '3'B4, 0, B1, B2);  /* COMBINE DESCRIPTORS  */
      CALL EMITRR ("12"B4, '1'B4, '1'B4, SOURCELINE() );  /* TEST FOR NULL FIRST OPERAND  */
      CALL EMITRR (BCR, 8, BRCHREG, SOURCELINE() );  /* RETURN WITH RESULT IN REG(3)  */
      CALL EMITRR (CMPRR, '3'B4, '1'B4, SOURCELINE() );  /* IS SECOND OPERAND NULL?  */
      CALL EMITRR (BCR, 8, BRCHREG, SOURCELINE() );  /* RETURN WITH RESULT IN REG(3)  */
      CALL FINDADDRESS (MASKF000);
      CALL EMITRX ("54"B4, '3'B4, 0, BIT(BINARY(ADREG, 8)), ADRDISP);  /* MASK OUT ADDRESS  */
      CALL EMITRX ("5E"B4, '3'B4, 0, DBR, CATCONST);  /* CORRECT LENGTH OF RESULT  */
      CALL FINDADDRESS (MOVER);  /* FIND MOVE INSTRUCTION */
      T1 = BIT(BINARY(ADREG, 8));  T2 = ADRDISP;
      CALL EMITRR ("18"B4, 0, '3'B4, SOURCELINE() );  /* SAVE LENGTH IN REG(0)  */
      CALL FINDADDRESS (TSA);  /* FIND CURRENT TOP OF STR AREA  */
      CALL EMITRX (LOAD, '2'B4, 0, BIT(BINARY(ADREG, 8)), ADRDISP);
      CALL FINDADDRESS (STRL);  /* LAST STRING MADE IN STRING AREA */
      CALL EMITRX (CMPR, '1'B4, 0, BIT(BINARY(ADREG, 8)), ADRDISP); /* SKIP MOVE IF AT TOP */
      J = PP;
      CALL BRANCH (6, 0);       /* FAKE MOVE */
      CALL EMITRX (LA, 1, 0, 1, 0);
      CALL EMITRR ("16"B4, 0, 1, SOURCELINE() );
      K = PP;
      CALL BRANCH ("F"B4, 0);
      CALL FIXBFW (J, PP);
      CALL EMITRR ("16"B4, 0, '2'B4, SOURCELINE() );  /* OR IN CORRECT ADDRESS */
      CALL EMITRX ("43"B4, '3'B4, 0, A1, A2);  /* INSERT LENGTH FIELD */
      CALL EMITRX ("44"B4, '3'B4, 0, T1, T2);   /* EXECUTE THE MOVE */
      CALL EMITRX ("41"B4, '2'B4, '3'B4, '02'B4, 1);  /* UPDATE TSA */
      CALL FIXBFW (K, PP);
      CALL EMITRX (LOAD, '1'B4, 0, B1, B2);  /* LOAD SECOND DESCRIPTOR */
      CALL EMITRX ("43"B4, '3'B4, 0, B1, B2);  /* INSERT LENGTH FIELD  */
      CALL EMITRX ("44"B4, '3'B4, 0, T1, T2);  /* EXECUTE THE MOVE */
      CALL EMITRX ("41"B4, '2'B4, '3'B4, '2'B4, 1);   /*  UPDATE TSA  */
      CALL EMITRX (STORE, 0, 0, BIT(BINARY(ADREG, 4)), ADRDISP);  /* STORE INTO STRL */
      CALL FINDADDRESS (TSA);
      CALL EMITRX (STORE, '2'B4, 0, BIT(BINARY(ADREG, 4)), ADRDISP);   /* SAVE TOP OF STR. A.  */
      CALL EMITRR ("18"B4, '3'B4, 0, SOURCELINE() );  /* RESULT TO REG(3)  */
      CALL EMITRR (BCR, 'F'B4, BRCHREG, SOURCELINE() );  /* RETURN  */
         /* Correction to previous line, 25 March 2009. */
   END CATENATE_CODE;

CATNUMBER_CODE:
   PROCEDURE;
      /* CATENATES A STRING AS THE FIRST OPERAND WITH A NUMBER AS THE SECOND.
         THE NUMBER IS FIRST CONVERTED TO STRING, AND PLACED ABOVE THE TOP OF
         FREE STRING AREA.
         CATENATE IS THEN FOOLED INTO PLACING THE SECOND OPERAND AGAINST THE
         FIRST, WITHOUT HAVING TO MOVE THE FIRST OPERAND,
         ASSUMING THAT THE FIRST WAS ALREADY AT THE TOP OF STRING AREA BEFORE
         THIS SUBROUTINE WAS CALLED.  ROUTINE AVOIDS CHEWING UP THE FREE STRING
         AREA & CUTS DOWN ON MOVES.
         THIS SUBROUTINE CALLS CONVERT_CODE & THEN CATENATE. */

      CATNUMNTRY = PP;
      CALL EMITDATAWORD(0);   /* A TEMPORARY */
      I = DP - 4; /* SAVE DP */
      CALL FINDADDRESS(I);
      CALL EMITRX(STORE,BRCHREG,0,ADREG,ADRDISP); /* SAVE THE RETURN BRANCH */
      CALL FINDADDRESS(STRL);
      CALL EMITRX(LOAD, 0, 0, ADREG, ADRDISP);
      CALL FINDADDRESS(DP);   /* THE ADDRESS OF A 2-WORD SAVE AREA */
      DP = DP + 4;            /* FOR THE 2ND WORD */
      CALL EMITRX(LOAD,1,0,DBR,TSA);
      CALL EMITRX("90"B4,0,1,ADREG,ADRDISP); /* SAVE STRL & TSA */
                                           /* STM  0,1,ADREG,ADRDISP */
      /* GET TRUE LENGTH OF FIRST STRING */
      CALL EMITRR("1B"B4, 3, 3, SOURCELINE() );
      CALL EMITRX("43"B4,3,0,A1,A2); /* LENGTH OF FIRST OPERAND */
      CALL EMITRX(LA,0,1,3,1);     /* TRUE LENGTH + A(TSA) */
      CALL EMITRX(STORE,0,0,DBR,TSA); /* UPDATE TSA */
      /* MAKE ROOM FOR FIRST OPERAND */
      CALL BRLINK_BD(0, NMBRNTRY); /* CONVERT TO STRING */
      CALL FINDADDRESS(I);         /* GET THE RETURN ADDRESS */
      CALL EMITRX(LOAD, BRCHREG, 0, ADREG, ADRDISP);
      CALL EMITRX(LOAD,1,0,A1,A2); /* LOAD FIRST DESCRIPTOR */
      CALL EMITRR("12"B4, 1, 1, SOURCELINE() ); /* TEST FOR NULL FIRST OPERAND */
      CALL EMITRR( BCR, 8, BRCHREG, SOURCELINE() ); /* RETURN WITH RESULT IN REG(3) */
                                     /* BOTH STRL & TSA ARE PROPERLY ADJUSTED */
      CALL FINDADDRESS(I+4);
      CALL EMITRX("98"B4,0,1,ADREG,ADRDISP); /* RESTORE OLD STRL & TSA */
      CALL FINDADDRESS(STRL);
      /* SET UP SECOND OPERAND FOR CATENATE */
      /* THE DESCRIPTOR FOR THE NUMBER */
      ON SIZE SNAP BEGIN;
         PUT SKIP DATA(B1, B2, ADREG, ADRDISP);
         GOTO LAST;
      END;
      CALL EMITSS("D2"B4, 3, ISLL(B1, 12)+B2, ISLL(ADREG,12)+ADRDISP);
LAST:
      CALL EMITRX(STORE,0,0,ADREG,ADRDISP);/* STORES ORIGINAL STRL */
      /* RESTORE ORIGINAL TSA */
      CALL EMITRX(STORE,1,0,DBR,TSA);
      /* FALL THRU TO CATENATE CODE.  THEN RETURN VIA BRCHREG TO CALLER */
   END CATNUMBER_CODE;

CONVERT_CODE:
   PROCEDURE;
      /*  THE NUMBER-TO-STRING CONVERSION SUBROUTINE */

      NMBRNTRY = PP;
      CALL CHECK_STRING_OVERFLOW;         /* CALL COMPACTIFY */
      CALL EMITRX (LOAD,0,0,DBR,STRN);  /* LOAD THE NUMBER INTO REGISTER 0 */
      CALL FINDADDRESS (DP);
      CALL EMITDATAWORD("40202020"B4);
      CALL EMITDATAWORD("20202020"B4);
      CALL EMITDATAWORD("20202120"B4);
      CALL EMITRX ("41"B4,1,0,ADREG,ADRDISP); /*ADDRESS OF PATTERN */
      CALL EMITRX (LOAD,3,0,DBR,TSA); /* ADDRESS OF THE STRING */
      /* MOVE THE TEMPLATE */
      CALL EMITSS("D2"B4, 11, "3000", "1000");  /* MVC 0(12,3),0(1)  */
      CALL EMITRR ("18"B4, 2, 3, SOURCELINE() );     /* LR   2,3     */
      CALL EMITCONSTANT ("FFFFF8"B4);
      CALL EMITRX ("54"B4, 2, 0, ADREG, ADRDISP);    /* N   2,=X"FFFFFC" *     */
      CALL EMITRX ("4E"B4, 0, 2, 0, 24);           /* CVD 0,24(2,0)
                      OFFSET 24 TO USE FREE STRING AREA AS WORK AREA */
      CALL EMITRX (LA,  1,0,3,12);
      CALL EMITRX (STORE,1,0,DBR,TSA);/*UPDATE THE STRING POINTER */
      CALL EMITRR ("06"B4, 1, 0, SOURCELINE() ); /* GET READY TO POINT AT SIGNIFICANT DIGIT */
      CALL EMITSS ("DF"B4, 11, "3000"B4, "201A"B4); /* EDMK  0(12,3),26(2)  */
      CALL BRANCH(10, PP+10);         /* BRANCH OVER THE NEXT 2 INSTRUCTIONS */
      CALL EMITRR ("06"B4,1,0, SOURCELINE() ); /* MAKE ROOM FOR SIGN */
      CALL EMITRX ("92"B4,0,BYTE('-'),1,0);/* MVI  0(1),C'-'    */
     /* THE BRANCH COMES IN HERE */
      CALL EMITRX (LOAD,3,0,DBR,TSA);     /* MAKE UP RESULT DESCRIPTOR */
      CALL EMITRR ("1B"B4, 3, 1, SOURCELINE() );
      CALL EMITRR ("06"B4, 3, 0, SOURCELINE() );
      CALL EMITRX ("89"B4,3,0,0,24);        /* SHIFT LENGTH FIELD LEFT */
      CALL EMITRR ("1A"B4, 3, 1, SOURCELINE() );     /* ADD IN ADDRESS */
      CALL FINDADDRESS (STRL);            /* UPDATE POINTER TO NEWEST STRING */
      CALL EMITRX (STORE, 3, 0, ADREG, ADRDISP);
      CALL EMITRR (BCR, 15, BRCHREG, SOURCELINE() );       /* RETURN */
   END CONVERT_CODE;


  /*                       TIME AND DATE                                 */


PRINT_TIME:
   PROCEDURE (MESSAGE, T);
      DECLARE MESSAGE CHARACTER (256) VARYING, T FIXED BINARY (31);

      MESSAGE = MESSAGE || TRIM(DIVIDE(T, BIN(360000), 31, 0)) || ':' ;

      PUT SKIP EDIT (MESSAGE,
         DIVIDE (MOD(T, 360000), BIN(6000), 31, 0), ':',
         DIVIDE (MOD(T,   6000), BIN( 100), 31, 0), '.',
         MOD(T, 100), '.')(A, P'99', A, P'99', A, P'99', A );
   END PRINT_TIME;

/*  OLD CODE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
PRINT_TIME:
   PROCEDURE (MESSAGE, T);
      DECLARE MESSAGE CHARACTER (256) VARYING, T FIXED BINARY (31);

      MESSAGE = MESSAGE || TRIM(DIVIDE(T, 360000, 31, 0)) || ':' ||
         EDIT(DIVIDE (MOD(T, 360000), 6000, 31, 0), '99') || ':' ||
         TRIM(DIVIDE (MOD(T, 6000), 100, 31, 0)) || '.';
      T = MOD(T, 100);  /* DECIMAL FRACTION  */
/*      IF T < 10 THEN MESSAGE = MESSAGE || '0';
      PUT SKIP EDIT (MESSAGE, TRIM(T), '.')(A);
   END PRINT_TIME;
*/

PRINT_DATE_AND_TIME:
   PROCEDURE (MESSAGE, D, T);
      DECLARE MESSAGE CHARACTER (*) VARYING, (D, T) FIXED BINARY (31),
          (YEAR, DAY, M) FIXED BINARY (15);
     DECLARE MONTH CHARACTER(48) STATIC INITIAL
          ('JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC ');
   DECLARE
      DAYS(0:12) FIXED BINARY (15) STATIC INITIAL (
         0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366);

      YEAR = DIVIDE(D, 1000, 31, 0) + 1900;
      DAY = MOD(D, 1000);
      IF IAND(YEAR, 3) ^= 0 THEN IF DAY > 59 THEN DAY = DAY + 1; /* ^ LEAP YEAR*/
      M = 1;
      DO WHILE (DAY > DAYS(M));  M = M + 1;  END;
      D = ISLL(M-1, 2);
      CALL PRINT_TIME(MESSAGE ||  TRIM(DAY-DAYS(M-1)) || X1 || SUBSTR(MONTH, D+1, 4)
         || TRIM(YEAR) || '.  CLOCK TIME = ', T);
   END PRINT_DATE_AND_TIME;

  /*                       INITIALIZATION                                     */



INITIALIZATION:
   PROCEDURE;

      PUT PAGE;
      CALL PRINT_DATE_AND_TIME( 'X P L -- Robin Vowels'' OPTIMIZING VERSION 4 OF ',
         DATE_OF_GENERATION, TIME_OF_GENERATION);
      PUT SKIP(2);
      CALL PRINT_DATE_AND_TIME ('TODAY IS ', XPL_DATE(), XPL_TIME());
      PUT SKIP(2);

      LB, MARGIN_CHOP = 0;
      CARD_COUNT = 0;
      BUFFER, TEXT, CURRENT_PROCEDURE, INFORMATION = '';
      MACRO_NAME = ''; MACRO_TEXT = ''; BCD = '';
      MACRO_INDEX = 0;

      CASEP = 0; CASESTACK = 0;
      CODEMAX, DATAMAX, STRNGMX = 0;
      IDCOMPARES = 0;

      DO I = 1 TO NT;
         S = V(I);
         IF S = '<NUMBER>' THEN NUMBER = I;  ELSE
         IF S = '<IDENTIFIER>' THEN IDENT = I;  ELSE
         IF S = '<STRING>' THEN STRING = I;  ELSE
         IF S = '/' THEN DIVIDE_OP = I;  ELSE
         IF S = '_|_' THEN EOFILE = I;  ELSE
         IF S = 'DECLARE' THEN STOPIT(I) = TRUE;  ELSE
         IF S = 'PROCEDURE' THEN STOPIT(I) = TRUE;  ELSE
         IF S = 'END' THEN STOPIT(I) = TRUE;  ELSE
         IF S = 'DO' THEN STOPIT(I) = TRUE;  ELSE
         IF S = ';' THEN STOPIT(I) = TRUE;  ELSE
         IF S = VBAR THEN ORSYMBOL = I; ELSE
         IF S = '||' THEN CONCATENATE = I; ELSE
         ;
      END;
      RESERVED_LIMIT = LENGTH(V(NT - (IDENT=NT)));
      V(EOFILE) = 'EOF';
      STOPIT(EOFILE) = TRUE;
      CHARTYPE(BYTE(' ')) = '00'B4;
      CHARTYPE(BYTE('''')) = '02'B4;
      CHARTYPE(BYTE('"')) = '03'B4;

      DO I = 0 TO LENGTH(ALPHABET) - 1;
         J = BYTE(ALPHABET, I);
         TX(J) = I;
         NOT_LETTER_OR_DIGIT(J) = FALSE;
         CHARTYPE(J) = '04'B4;
      END;

      DO I = 0 TO 9;
         J = BYTE(HEXCODES, I);
         NOT_LETTER_OR_DIGIT(J) = FALSE;
         CHARTYPE(J) = '05'B4;
      END;

      DO I = V_INDEX(0) TO V_INDEX(1) - 1;
         J = BYTE(V(I));
         TX(J) = BIT(BINARY(I, 8));
         CHARTYPE(J) = '07'B4;
      END;

      CHARTYPE(BYTE('_')) = '01'B4; /* THE UNDERSCORE MAY NOT START AN IDENTIFIER */
      CHARTYPE(BYTE('|')) = '08'B4;
      CHARTYPE(BYTE('/')) = '06'B4;
      COMMUTATIVE(CMPRR),
      COMMUTATIVE("14"B4) = TRUE;
      COMMUTATIVE("16"B4) = TRUE;
      COMMUTATIVE("1A"B4) = TRUE;
      RETURNED_TYPE = FIXEDTYPE;          /* DEFAULT RETURN TYPE */

      LASTBASE = DBR;  BASES(LASTBASE) = 0;
      /*              INITIALIZE SYMBOL TABLE VARIABLES */
      PP = 60;   /*  OFFSET  CODE  FOR  CONTROL  RECORD (SEE LOADER) */
      DP = 0;    /*  DATA ORIGIN  */
      DSP = 4;
      CHP = 1;
      PPLIM, DPLIM, CHPLIM = DISKBYTES;
         /* UPPER BOUND FOR EMITTER ARRAYS */
      PPORG, DPORG, CHPORG,
         /* LOWER BOUND FOR EMITTER ARRAYS */
      CURCBLK, CURDBLK, CURSBLK,
         /* CURRENT BLOCK OCCUPYING EMITTER ARRAYS */
      SHORTCFIX, SHORTDFIX, LONGCFIX, LONGDFIX,
         /* STATISTICAL COUNTERS FOR FIXUPS */
      FCP = 0;  /* POINTER INTO FIXUP ARRAY */
      NDECSY ,PROCMARK = 1;   PARCT = 0;
      /* INTEGERS FOR BRANCH ADDRESSING */

      DO I = 0 TO PROGRAMSIZE;  CALL EMITDATAWORD(ISLL(I,12)); END;

      /*  WARNING, THE FOLLOWING SECTION OF INITIALIZE DEPENDS ON
          THE INITIALIZATION OF THE BUILTIN FUNCTION AND PSEUDO
          VARIABLE NAMES AND ATTRIBUTES IN THE SYMBOL TABLE ARRAYS.
      */

      IO_SAVE = DP; DP = DP + 16; /* REGSAVE FOR I/O & MONITOR_LINK */
      MASKF000 = DP;
      I = ISLL('FF00'B4, 16);
      CALL EMITDATAWORD(I); /* The constant 'FF000000'B4. */

      /*  SET UP THE MOVE TEMPLATE IN DATA AREA */

      MOVER = DP; /* Already on a word boundary. */
      CALL EMITBYTE('D2'B4);/* Emits 'D200 2000 1000' = MVC 0,0(2),0(1)  */
      CALL EMITBYTE('00'B4);
      CALL EMITBYTE('20'B4);
      CALL EMITBYTE('00'B4);
      CALL EMITBYTE("10"B4);
      CALL EMITBYTE('00'B4);
      CALL EMITDATAWORD(0);  TSA = DP-4;
      CALL EMITDATAWORD(4); /* CONSTANT 4 FOR INPUT IN FORCEACCUMULATOR */
      SYDISP(3) = BIT(BINARY(DP, 12));     /*  TIME_OF_GENERATION         */
      CALL EMITDATAWORD(XPL_TIME());
      SYDISP(4) =  BIT(BINARY(DP, 12));    /*  DATE_OF_GENERATION         */
      CALL EMITDATAWORD(XPL_DATE());
      SYDISP(7) = BIT(BINARY(TSA, 12));    /*  FREEPOINT                  */
      SYDISP(8) = BIT(BINARY(DSP, 12));    /*  DESCRIPTOR                 */
      SYDISP(9) = BIT(BINARY(DP,  12));    /*  NDESCRIPT                  */
      DESCL = DP;
      CALL EMITDATAWORD (0);
      A1, B1 = SBR;  /* A1,A2 IS THE FIRST PARAMETER TO ||, */
      A2 = DSP;       /* B1,B2 IS THE SECOND */
      CALL EMITDESC (0);
      B2 = DSP;
      CALL EMITDESC (0);
      STRL = -DSP;  CALL EMITDESC(0);
      STRN = DP; CALL EMITDATAWORD(0);
      INFORMATION = '';
      CALL EMITCONSTANT(TRUE); TRUELOC = ADRDISP; INFORMATION='';
      CALL EMITBYTE ('FF'B4); CALL EMITBYTE ('FF'B4); /* Emit minus 1. */
      CALL EMITBYTE ('FF'B4); CALL EMITBYTE ('FF'B4);
      COMPLOC = ADRDISP; INFORMATION='';
      CATCONST = DP; CALL EMITDATAWORD ("1000000"B4);
      RTNADR = DP; CALL EMITDATAWORD (0);
      STRING_RECOVER, NDECSY = 29; /* ONE BEYOND LAST FUNCTION NAME */

      /* INITIALIZE HASH INDEXES */
      DO I = 2 TO NDECSY; /* INITIALIZE RESERVED WORD POINTERS */
         IDX = HASHER(SYT(I));
         PTR(I) = HASH(IDX);
         HASH(IDX) = I;
      END;

      CALL EMITDATAWORD (0);
      SYDISP(NDECSY) = BIT(BINARY(DP-4, 12));     /*  COMPACTIFY                 */
      SYBASE(NDECSY) = DBR;
      CALL CLEARREGS;


      /*         EMIT CODE FOR BUILT_IN FUNCTIONS                        */

      CALL REGISTER_SETUP_CODE;

      CALL RELOCATE_DESCRIPTORS_CODE;

      CALL CONVERT_CODE;

      CALL CATNUMBER_CODE;

/*CONTROL(BYTE('E')) = TRUE;*/

      CALL CATENATE_CODE;

      CALL FIXBFW (NMBRNTRY-4,PP); /* BRING BRANCH HERE TO 1ST COMPILED CODE*/

      MAINLOC = PP;
      CALL CLEARREGS;
      /* FIRST SET UP GLOBAL VARIABLES CONTROLLING SCAN, THEN CALL IT */
      CP = 0;  TEXT_LIMIT = -1;
      TEXT, CURRENT_PROCEDURE = '';

      CALL SCAN;

      /* INITIALIZE THE PARSE STACK */
      SP = 1;  PARSE_STACK(SP) = EOFILE;

   END INITIALIZATION;



  /*               SYMBOL AND STATISTICS PRINTOUT                         */


SYMBOLDUMP:
   PROCEDURE;
      /* LISTS THE SYMBOLS IN THE PROCEDURE THAT HAS JUST BEEN
         COMPILED IF $S OR $D IS ENABLED.
         [MAINTAIN PARITY ON ^$S AND  $D]
      */
      DECLARE (I,J,K,L,M) FIXED BINARY (31),

      BUFFER CHARACTER (256) VARYING,
      SYTSORT(0:SYTSIZE) FIXED BINARY (15);

   STRING_GT:
      PROCEDURE(A,B) RETURNS (BIT(1));
         /* DOES AN HONEST STRING COMPARE FOR A > B. USES THE
            KNOWLEDGE THAT NEITHER A NOR B MAY CONTAIN BLANKS */
         DECLARE (A,B) CHARACTER (*) VARYING, (LA, LB) FIXED BINARY (15);

         LA = LENGTH(A);  LB = LENGTH(B);
         IF LA = LB  THEN RETURN (A>B); /* XCOM IS HONEST */
         ELSE IF LA > LB THEN RETURN (SUBSTR(A,1,LB)>=B);
         ELSE RETURN (A>SUBSTR(B,1,LA));
      END STRING_GT;
      OUTLINE:
         PROCEDURE (NAME, P) RETURNS (CHARACTER (256) VARYING);
            DECLARE NAME CHARACTER (*) VARYING, (P, B, D) FIXED BINARY (31);

            IF SYTYPE(P) = LABELTYPE | SYTYPE(P) = CHAR_PROC_TYPE THEN
               DO;
                  B = PBR;
                  D = ISLL(SYBASE(P), 12) + SYDISP(P);
               END;
            ELSE
               DO;
                  B = SYBASE(P);
                  D = SYDISP(P);
               END;

            IF SYTCO(P) = 0 THEN
               S = ' & not referenced';
            ELSE
               S = ' & referenced ' || TRIM(SYTCO(P)) || ' times';
            BUFFER = PAD ( TRIM(D) || LPAR || TRIM(B) || '),', 11);
            RETURN (NAME || ': ' || TYPENAME(SYTYPE(P)) || ' at ' || BUFFER ||
               ' declared on line ' || TRIM(DECLARED_ON_LINE(P)) || S);

         END  OUTLINE;


      IF PROCMARK <= NDECSY THEN
         DO;
            PUT SKIP(2);
            PUT SKIP LIST ( 'SYMBOL  TABLE  DUMP' );
            PUT SKIP(2);
            DO I = PROCMARK TO NDECSY;
               SYTSORT(I) = I;
            END;
            K = NDECSY - PROCMARK; M = ISRL(K+1, 1);
            DO WHILE (M>0);
               DO J = PROCMARK TO PROCMARK+K-M;
                  I = J; L = SYTSORT(I);
                  DO WHILE (STRING_GT(SYT(L         ), SYT(SYTSORT(I+M))));
                     SYTSORT(I) = SYTSORT(I+M); /*SWAP*/
                     SYTSORT(I+M) = L;
                     I = I - M;
                     IF I < PROCMARK THEN GOTO LM;
                     L = SYTSORT(I);
                  END;
            LM:END;
               M = ISRL(M,1);
            END;
            I = PROCMARK;
            DO WHILE (LENGTH(SYT(SYTSORT(I))) = 0);
               I = I+1; /* IGNORE NULL NAMES */
            END;
            DO I = I TO NDECSY;
               K = SYTSORT(I);
               PUT SKIP LIST (OUTLINE(PAD(SYT(K), 23), K) );
               K = K+1;
               DO WHILE ((LENGTH(SYT(K))=0) & (K <= NDECSY));
                  J = K - SYTSORT(I);
                  PUT SKIP LIST ( OUTLINE('  PARAMETER  ' || TRIM(J) || (9)' ', TRIM(K)) );
                  K = K+1;
               END;
            END;
         PUT SKIP(2);
         END;

   END  SYMBOLDUMP;



DUMPIT:
   PROCEDURE;    /* DUMP OUT THE COMPILED CODE & DATA AREAS  */
   DECLARE TITLE    CHARACTER(420) STATIC INITIAL( (
'IDCOMPARESSYMBOL TABLE SIZEMACRO DEFINITIONSSTACKING DECISIONSSCANEMITRREMITRXFO' ||
'RCEACCUMULATORARITHEMITGENSTOREFIXBFWFIXDATAWORDFIXCHWGETDATAGETCODEFINDADDRESSS' ||
'HORTCFIXLONGCFIXSHORTDFIXLONGDFIXFREESTRINGAREAMAX STACK DEPTHREGISTER VALUES (R' ||
'ELATIVE TO R11):'));
   DECLARE INDEX(0:22) UNSIGNED FIXED BINARY(8) STATIC INITIAL(
      0,10,27,44,62,66,72,78,94,103,111,117,128,134,141,148,158,168,176,
      185,193,207,222);
      CALL SYMBOLDUMP;
      PUT SKIP LIST ( SUBSTR(TITLE, 28,17) ); /*'MACRO DEFINITIONS' */
      PUT SKIP(2);
      DO I = 0 TO TOP_MACRO;
         PUT SKIP EDIT ( PAD(MACRO_NAME(I), 20), ' LITERALLY: ', MACRO_TEXT(I) ) (A);
      END;
      PUT SKIP(2);
      /*  PUT OUT THE ENTRY COUNT FOR IMPORTANT PROCEDURES */

      FIXV(0) = IDCOMPARES;         FIXV( 1) = MAXNDECSY;
      FIXV(2) = TOP_MACRO+1;        FIXV( 3) = COUNT#STACK;
      FIXV(4) = COUNT#SCAN;         FIXV( 5) = COUNT#RR;
      FIXV(6) = COUNT#RX;           FIXV( 7) = COUNT#FORCE;
      FIXV(8) = COUNT#ARITH;        FIXV( 9) = COUNT#STORE;
      FIXV(10)= COUNT#FIXBFW;       FIXV(11) = COUNT#FIXD;
      FIXV(12)= COUNT#FIXCHW;       FIXV(13) = COUNT#GETD;
      FIXV(14)= COUNT#GETC;         FIXV(15) = COUNT#FIND;
      FIXV(16)= SHORTCFIX;          FIXV(17) = LONGCFIX;
      FIXV(18)= SHORTDFIX;          FIXV(19) = LONGDFIX;
      FIXV(20)= FREELIMIT-FREEBASE; FIXV(21) = STACKMAX;
      DO I=0 TO 21;
         J = INDEX(I);
         K = INDEX(I+1)-J;
         PUT SKIP LIST ( PAD(SUBSTR(TITLE, J+1, K), 18) || EQUALS || TRIM(FIXV(I)) );
      END;
      PUT SKIP(2);
      PUT SKIP LIST ( SUBSTR(TITLE, 223, 34) ); /* 'REGISTER VALUES REL REG 11' */
      S='';
      DO I = 4 TO 13;
         S = S || ' R' || TRIM(I) || EQUALS || TRIM(BASES(I));
      END;
      PUT SKIP LIST ( S );

      PUT SKIP(2) LIST ( ' INSTRUCTION FREQUENCIES:' );
      PUT SKIP;
      S = '';
      DO I = 0 TO 255;
         IF INSTRUCT(I) > 0 THEN
            DO;
               CHAR_TEMP=SUBSTR(OPNAMES, ISLL(OPER(I),2)+1, 4) || X4 || TRIM(INSTRUCT(I));
               IF LENGTH(S)>0 THEN
                  DO;
                     PUT SKIP EDIT (PAD(S,20), CHAR_TEMP )(A);
                     S='';
                  END;
               ELSE
                  S=CHAR_TEMP;
            END;
      END;
      PUT SKIP LIST (S);
   END DUMPIT;


STACK_DUMP:
   PROCEDURE;
      DECLARE LINE CHARACTER (256) VARYING;

      LINE = 'PARTIAL PARSE TO THIS POINT IS: ';
      DO I = 2 TO SP;
         IF LENGTH(LINE) > 105 THEN
            DO;
               PUT SKIP LIST (LINE);
               LINE = X4;
            END;
         LINE = LINE || X1 || V(PARSE_STACK(I));
      END;
      PUT SKIP LIST (LINE);
   END STACK_DUMP;


  /*                  THE SYNTHESIS ALGORITHM FOR XPL                      */


SYNTHESIZE:
PROCEDURE(PRODUCTION_NUMBER);
   DECLARE PRODUCTION_NUMBER FIXED BINARY (7);

   /*  ONE STATEMENT FOR EACH PRODUCTION OF THE GRAMMAR*/


SELECT (PRODUCTION_NUMBER);
   WHEN (0) ;      /*  CASE 0 IS A DUMMY, BECAUSE WE NUMBER PRODUCTIONS FROM 1  */

 /*  <PROGRAM>  ::=  <STATEMENT LIST>    */
   WHEN (1)
   DO;   /* FINAL CODE FOR XPLSM INTERFACE & SETUP  */
      IF MP ^= 2 THEN  /* WE DIDN'T GET HERE LEGITIMATELY  */
         DO;
            CALL ERROR ('EOF AT INVALID POINT', 1);
            CALL STACK_DUMP;
         END;
      DO I = 1 TO NDECSY;
         IF SYTYPE(I) = FORWARDTYPE | SYTYPE(I) = FORWARDCALL THEN
          IF SYTCO(I) > 0 THEN
            CALL ERROR ('UNDEFINED LABEL OR PROCEDURE: ' || SYT(I), 1);
      END;
      IF PP>ISLL(PROGRAMSIZE,12) THEN
            CALL ERROR(   'PROGRAM SIZE EXCEEDS ' || ISLL(PROGRAMSIZE,12) ||
                   ' BYTES. SUCCESSFUL EXECUTION IS IMPOSSIBLE', 1);
      CALL EMITRR ("1B"B4, 3, 3, SOURCELINE() );  /* RETURN CODE OF ZERO  */
      CALL EMITRX(LOAD, BRCHREG, 0, DBR, RTNADR);
      CALL EMITRR(BCR, "F"B4, BRCHREG, SOURCELINE() );  /* SET UP BASE REGISTERS */
      BASES(SBR) = IAND(DP + 3, "FFFFFC"B4);
      DO I = 4 TO DBR-1;
         CALL FIXWHOLEDATAWORD(BASEDATA+ISLL(I,2), BASES(I));
      END;
      CALL FIXWHOLEDATAWORD(DESCL, ISRL(DSP,2)-1);
      COMPILING = FALSE;
   END;

 /*  <STATEMENT LIST> ::= <STATEMENT>    */
   WHEN (2) ;
 /*  <STATEMENT LIST> ::= <STATEMENT LIST> <STATEMENT>    */
   WHEN (3);
 /*  <STATEMENT> ::= <BASIC STATEMENT>    */
   WHEN (4)
      DO;
         CALL CLEARREGS;
         STATEMENT_COUNT = STATEMENT_COUNT + 1;
      END;

 /*  <STATEMENT> ::= <IF STATEMENT>    */
   WHEN (5) CALL CLEARREGS;

 /*  <BASIC STATEMENT> ::= <ASSIGNMENT> ;    */
   WHEN (6) ;
 /*  <BASIC STATEMENT> ::= <GROUP> ;    */
   WHEN (7) ;
 /*  <BASIC STATEMENT> ::= <PROCEDURE DEFINITION> ;    */
   WHEN (8) ;
 /*  <BASIC STATEMENT> ::= <RETURN STATEMENT> ;    */
   WHEN (9) ;
 /*  <BASIC STATEMENT> ::= <CALL STATEMENT> ;    */
   WHEN (10) ;
 /*  <BASIC STATEMENT> ::= <GO TO STATEMENT> ;    */
   WHEN (11) ;
 /*  <BASIC STATEMENT> ::= <DECLARATION STATEMENT> ;    */
   WHEN (12) ;

 /*  <BASIC STATEMENT> ::= ;    */
   WHEN (13) ;
 /*  <BASIC STATEMENT> ::= <LABEL DEFINITION> <BASIC STATEMENT>    */
      WHEN (14) ;
 /*  <IF STATEMENT> ::= <IF CLAUSE> <STATEMENT>    */
   WHEN (15)
      CALL FIXBFW(FIXL(MP), PP); /* FIX THE ESCAPE BRANCH NOW THAT STMT IS DONE */

 /*  <IF STATEMENT> ::= <IF CLAUSE> <TRUE PART> <STATEMENT>    */
   WHEN (16)
   DO;  /* THERE ARE TWO BRANCHES TO BE FILLED IN WITH ADDRESSES HERE */
      CALL FIXBFW(FIXL(MPP1), PP); /* ESCAPE FROM TRUE PART */
      CALL FIXBFW(FIXL(MP), FIXV(MPP1)); /* HOP AROUND TRUE PART */
   END;

 /*  <IF STATEMENT> ::= <LABEL DEFINITION> <IF STATEMENT>    */
   WHEN (17) ;

 /*  <IF CLAUSE> ::= IF <EXPRESSION> THEN    */
   WHEN (18) CALL BOOLBRANCH(MPP1, MP); /* BRANCH ON FALSE OVER TRUE PART */

  /*  <TRUE PART> ::= <BASIC STATEMENT> ELSE   */
WHEN (19)
   DO;  /* SAVE THE PROGRAM POINTER & EMIT THE CONDITIONAL BRANCH */
      FIXL(MP) = PP;
      CALL BRANCH("F"B4, 0); /* "F" MEANS UNCONDITIONAL BRANCH */
      FIXV(MP) = PP;
   END;

 /*  <GROUP> ::= <GROUP HEAD> <ENDING>    */
WHEN (20)
   DO;  /* BRANCH BACK TO LOOP & FIX ESCAPE JUMP */
      IF INX(MP)=1 THEN /* STEP DEFINITION LOOP FIXUP */
         DO;
            /* UNPACK OPERATIONS */
            L = ISLL(TYPE(MP), 8) + CNT(MP); /* VARIABLE'S INDEX IN STACK */
            ADREG = SYBASE(L);
            ADRDISP = SYDISP(L);
            REG1 = REG(MP);
            OP1 = LOAD;
            IF SYTYPE(L)=BYTETYPE THEN
               DO;
                  CALL EMITRR("1B"B4, REG1, REG1, SOURCELINE() );
                  OP1 = "43"B4; /* IC */
               END;
            ELSE IF SYTYPE(L)=HALFWORD THEN OP1 = "48"B4; /* LH */
            CALL EMITRX (OP1, REG1, 0, BIT(BINARY(ADREG, 8)), ADRDISP);   /* LOAD THE VARIABLE */
            J = FIXV(MP);                                 /* ADD  THE INCREMENT */
            CALL EMITRX("5A"B4, REG1, 0, BIT(BINARY(ISRL(J,28), 8)), IAND(ISRL(J,16), "FFF"B4));
            CALL FIXBFW(PPSAVE(MP),PP);          /* ENTER THE LOOP HERE */
            IF OP1 = "43"B4 THEN OP1 = "42"B4; ELSE OP1 = BIT(BINARY(OP1-8, 8));
                      /* OP-8 prepares 'STORE' opcode, either '50' or '40' for ST or STH. */
            CALL EMITRX(OP1, REG1, 0, BIT(BINARY(ADREG, 8)), ADRDISP);
                      /* STORE INCREMENTED VARIABLE */
            CALL EMITRX(CMPR, REG1, 0, IAND(ISRL(J,12), "0F"B4), IAND(J, "FFF"B4));
            /* CONDITIONAL BRANCH TO HEAD OF CODE IN LOOP */
            CALL BRANCH(BIT(BINARY(12-ISLL(NEG_INCREMENT,1), 8)), FIXL(MP));
            /* FOR NEGATIVE INCREMENTS, CONDITION CODE =10 */
            NEG_INCREMENT = FALSE;
         END;
      ELSE IF INX(MP)=2 THEN /* WHILE LOOP FIXUP */
         DO;
            CALL BRANCH("0F"B4, PPSAVE(MP));
            CALL FIXBFW(FIXL(MP), PP);
         END;
      ELSE IF  INX(MP) = 3 THEN
         DO;  /* COMMENT  CASE GROUP */
            /* JUSTIFY TO WORD BOUNDARY */
            DP = IAND(DP + 3, "FFFFFC"B4);
            CALL FINDADDRESS(DP);
            CALL FIXCHW(FIXL(MP)+2,
                 BIT(BINARY(ISLL(ADREG,4)+ISRL(ADRDISP,8), 8)),
                 BIT(BINARY(IAND(ADRDISP, "FF"B4), 8)) );
            DO I = PPSAVE(MP) TO CASEP-1; CALL EMITDATAWORD(CASESTACK(I)); END;
            CASEP = PPSAVE(MP) - 1;
            CALL FIXBFW(FIXV(MP), PP);
         END;
      IF LENGTH(VAR(SP)) > 0 THEN IF VAR(MP-1) ^= VAR(SP) THEN
         CALL ERROR ('END ' || VAR(SP) || '  MUST MATCH LABEL ON GROUP', 0);
   END;

 /*  <GROUP HEAD> ::= DO ;    */
   WHEN (21) INX(MP) = '00'B4;

 /*  <GROUP HEAD> ::= DO <STEP DEFINITION> ;    */
   WHEN (22)
   DO;
      CALL MOVESTACKS(MPP1, MP);
      INX(MP) = '01'B4;  /* 1 DENOTES STEP */
   END;

 /*  <GROUP HEAD> ::= DO <WHILE CLAUSE> ;    */
   WHEN (23)
   DO;
      PPSAVE(MP) = PPSAVE(MPP1);
      FIXL(MP) = FIXL(MPP1);
      INX(MP) = '02'B4;  /* 2 DENOTES WHILE */
   END;

 /*  <GROUP HEAD> ::= DO <CASE SELECTOR> ;    */
   WHEN (24)
   DO;
      CALL MOVESTACKS(MPP1, MP);
      INX(MP) = '03'B4;  /* 3 DENOTES CASE  */
      INFORMATION = INFORMATION || ' CASE 0.';
   END;

 /*  <GROUP HEAD> ::= <GROUP HEAD> <STATEMENT>    */
   WHEN (25)
   IF  INX(MP) = '03'B4 THEN
      DO;  /* CASE GROUP, MUST RECORD STATEMENT ADDRESSES */
         CALL BRANCH ("0F"B4, FIXV(MP));
      IF CASEP >= CASELIMIT THEN CALL ERROR ('TOO MANY CASES', 1);
         ELSE CASEP = CASEP + 1;  CASESTACK(CASEP) = PP;
      IF BCD ^= 'END' THEN
            INFORMATION = INFORMATION || ' CASE ' || TRIM(CASEP-PPSAVE(MP)) || PERIOD;
      END;

 /*  <STEP DEFINITION> ::= <VARIABLE> <REPLACE> <EXPRESSION> <ITERATION CONTROL> */
   WHEN (26)
   DO; /* EMIT CODE FOR STEPPING DO LOOPS */
      CALL FORCEACCUMULATOR(MP+2);
      IF INX(MP) ^= '00'B4 THEN
         CALL ERROR ('SUBSCRIPTED DO VARIABLE', 0);
      PPSAVE(MP) = PP;
      CALL BRANCH("0F"B4, 0);
      /* DO A BIT OF SQUEEZING--SAVE REGISTER NOS, BASES & DISPLACEMENTS */
      REG(MP) = REG(MP+2); /* SAVE REGISTER NUMBER */
      TYPE(MP) = BIT(BINARY(ISRL(FIXL(MP), 8), 8)); /* POINTER TO THE VARIABLE, upper 8 bits. */
      CNT(MP) = BIT(BINARY(IAND(FIXL(MP), 'FF'B4), 8)); /* POINTER TO THE VARIABLE, lower 8 bits. */
      /* THE <EXPRESSION> : TOO MANY ACCUMULATORS */
      I = ISLL(INX(SP),12) + FIXV(SP);
      /* FIXV CONTAINS PACKED BASE & DISPLACEMENT FOR
                       <INCREMENT> IN BITS 0-16, & <EXPRESSION> IN BITS 17-31 */
      FIXV(MP) = ISLL(ISLL(REG(SP  ),12)+FIXL(SP  ),16) + I;
      FIXL(MP) = PP; /* REMEMBER HEAD OF LOOP */
      BASES(INX(MP)), BASES(REG(MP)) = AVAIL;
   END;

 /*  <ITERATION CONTROL> ::= TO <EXPRESSION>    */
   WHEN (27)
   DO;
      REG(MP) = DBR;
      FIXL(MP) = TRUELOC;  /* POINT AT THE CONSTANT ONE FOR STEP  */
      CALL SET_LIMIT(MPP1);
      INX(MP) = BIT(BINARY(ADREG, 4));
      FIXV(MP) = ADRDISP;
      NEG_INCREMENT=FALSE;
   END;

 /*  <ITERATION CONTROL> ::= TO <EXPRESSION> BY <EXPRESSION>    */
   WHEN (28)
   DO;
      IF TYPE(SP)=CONSTANT THEN
         NEG_INCREMENT  =  FIXV(SP) < 0;  /* TRUE FOR NEGATIVE CONSTANTS */
      ELSE NEG_INCREMENT = FALSE;
      CALL SET_LIMIT(SP);
      REG(MP) = BIT(BINARY(ADREG, 4));
      FIXL(MP) = ADRDISP;
      CALL SET_LIMIT(MPP1);
      INX(MP) = BIT(BINARY(ADREG, 4));
      FIXV(MP) = ADRDISP;
   END;

 /*  <WHILE CLAUSE> ::= WHILE <EXPRESSION>    */
   WHEN (29) CALL BOOLBRANCH(SP, MP);

 /*  <CASE SELECTOR> ::= CASE <EXPRESSION>    */
   WHEN (30)
   DO;
      CALL FORCEACCUMULATOR(SP);
      CALL EMITRX("89"B4, REG(SP), 0, 0, 2);
      FIXL(MP) = PP;
      CALL EMITRX(LOAD, REG(SP), REG(SP), 0, 0);
      CALL EMITRX(BC, "0F"B4, REG(SP), PBR, 0);
      BASES(REG(SP)) = AVAIL;
      FIXV(MP) = PP;
      CALL BRANCH("F"B4, 0);
      IF CASEP >= CASELIMIT THEN CALL ERROR ('TOO MANY CASES', 1);
      ELSE CASEP = CASEP + 1;
      CASESTACK(CASEP) = PP;
      PPSAVE(MP) = CASEP;
   END;

 /*  <PROCEDURE DEFINITION> ::= <PROCEDURE HEAD> <STATEMENT LIST> <ENDING>    */
   WHEN (31)
   DO; /* PROCEDURE IS DEFINED, RESTORE SYMBOL TABLE */
      IF LENGTH(VAR(SP)) > 0 THEN
         IF SUBSTR(CURRENT_PROCEDURE, 2) ^= VAR(SP) THEN
            CALL ERROR ('PROCEDURE' || CURRENT_PROCEDURE || ' CLOSED BY END ' ||
               VAR(SP), 0);
      IF CONTROL(BYTE('S')) THEN CALL SYMBOLDUMP;
      DO I = PROCMARK TO NDECSY;
         IF SYTYPE(I) = FORWARDTYPE | SYTYPE(I) = FORWARDCALL THEN
          IF SYTCO(I) > 0 THEN
            CALL ERROR ('UNDEFINED LABEL OR PROCEDURE: ' || SYT(I), 1);
      END;
      /* REMOVE THE INDENTIFIERS DECLARED IN THIS PROCEDURE
         FROM THE SYMBOL TABLE */
      M = PROCMARK+PARCT;
      DO I = 0 TO NDECSY+1-M;
         J = NDECSY-I;
         IF (J>=M) & (LENGTH(SYT(J))>0) THEN
            DO; /* UNWIND THE HASH POINTERS */
               HASH(HASHER(SYT(J))) = PTR(J);
               PTR(J) = -1;
            END;
      END;
      DO I = PROCMARK + PARCT  TO  NDECSY + 1;
         SYT(I) = X1;
      END;
      NDECSY = PROCMARK + PARCT - 1;
      /* PARAMETER ADDRESS MUST BE SAVED BUT NAMES DISCARDED */
      DO J = 0 TO NDECSY-PROCMARK;
         I = NDECSY - J;
         IF SYTYPE(I) = 0 THEN
            DO;
               CALL ERROR('UNDECLARED PARAMETER:' || SYT(I));
               SYTYPE(I) = FIXEDTYPE;
               CALL EMITDATAWORD(0);
               CALL FINDADDRESS(DP-4);
               SYBASE(I) = BIT(BINARY(ADREG, 4));
               SYDISP(I) = BIT(BINARY(ADRDISP, 12));
            END;
         HASH(HASHER(SYT(I))) = PTR(I);
         PTR(I) = -1;
         SYT(I) = '';
      END;
      CURRENT_PROCEDURE = VAR(MP);
      PROCMARK = FIXV(MP);  PARCT = CNT(MP);
      RETURNED_TYPE = TYPE(MP) ;
      /* EMIT A GRATUITOUS RETURN */
      CALL FINDADDRESS(RTNADR);
      CALL EMITRX(LOAD, BRCHREG, 0, BIT(BINARY(ADREG, 8)), ADRDISP);
      CALL EMITRR(BCR, "0F"B4, BRCHREG, SOURCELINE() );
      RTNADR = PPSAVE(MP);
      CALL FIXBFW(FIXL(MP), PP); /* COMPLETE JUMP AROUND PROCEDURE DEFINITION */
   END;

 /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> ;    */
   WHEN (32)
   DO;  /* MUST POINT AT FIRST PARAMETER EVEN IF NONEXISTENT  */
      /* SAVE OLD PARAMETER COUNT */
      CNT(MP) = BIT(BINARY(PARCT, 8)); PARCT = 0;
      /* SAVE OLD PROCEDURE MARK IN SYMBOL TABLE */
      FIXV(MP) = PROCMARK;  PROCMARK = NDECSY + 1;
      TYPE(MP) = RETURNED_TYPE;
      RETURNED_TYPE = 0;
      CALL PROC_START;
   END;


 /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <TYPE> ;    */
   WHEN (33)
   DO;
      CNT(MP) = BIT(BINARY(PARCT, 8));
      PARCT = 0;
      FIXV(MP) = PROCMARK;
      PROCMARK = NDECSY + 1;
      TYPE(MP) = RETURNED_TYPE;
      RETURNED_TYPE = TYPE(SP-1);
      IF RETURNED_TYPE = CHRTYPE THEN
         SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE ;
      CALL PROC_START;
   END;

 /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> ;    */
   WHEN (34)
   DO;
      CNT(MP) = CNT(MPP1);  /* SAVE PARAMETER COUNT */
      FIXV(MP) = FIXV(MPP1);
      TYPE(MP) = RETURNED_TYPE;
      RETURNED_TYPE = 0;
      CALL PROC_START;
   END;


 /*  <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> <TYPE> ;       */
   WHEN (35)
   DO;
      CNT(MP) = CNT(MPP1);
      FIXV(MP) = FIXV(MPP1);
      TYPE(MP) = RETURNED_TYPE;
      RETURNED_TYPE = TYPE(SP-1);
      IF RETURNED_TYPE = CHRTYPE THEN
         SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE ;
      CALL PROC_START;
   END;

 /*  <PROCEDURE NAME> ::= <LABEL DEFINITION> PROCEDURE    */
   WHEN (36)
   DO;
      S = CURRENT_PROCEDURE;
      CURRENT_PROCEDURE = X1 || VAR(MP);
      VAR(MP) = S;
   END;

 /*  <PARAMETER LIST> ::= <PARAMETER HEAD> <IDENTIFIER> )    */
   WHEN (37)
   DO;
      PARCT = PARCT + 1;
      Dummy = ENTER (VAR(MPP1), 0, 0, 0);
   END;

 /*  <PARAMETER HEAD> ::= (   */
   WHEN (38)
   DO;  /* POINT AT THE FIRST PARAMETER FOR SYMBOL TABLE */
      FIXV(MP) = PROCMARK;  PROCMARK = NDECSY + 1;
      CNT(MP) = BIT(BINARY(PARCT, 8));
      PARCT = 0;
   END;

 /*  <PARAMETER HEAD> ::= <PARAMETER HEAD> <IDENTIFIER> ,    */
   WHEN (39)
   DO;
      PARCT = PARCT + 1;
      Dummy = ENTER (VAR(MPP1), 0, 0, 0);
   END;

 /*  <ENDING> ::= END    */
   WHEN (40) VAR(MP) = '';

 /*  <ENDING> ::= END <IDENTIFIER>    */
   WHEN (41) VAR(MP) = VAR(SP);

 /*  <ENDING> ::= <LABEL DEFINITION> <ENDING>    */
   WHEN (42) VAR(MP) = VAR(SP);

 /*  <LABEL DEFINITION> ::= <IDENTIFIER> :    */
   WHEN (43) FIXL(MP) = ENTER (VAR(MP), LABELTYPE, PP, FIXL(MP));


 /*  <RETURN STATEMENT> ::= RETURN    */
   WHEN (44)
   DO;  /* EMIT A RETURN BRANCH */
      CALL FINDADDRESS(RTNADR);
      CALL EMITRX(LOAD, BRCHREG,0,ADREG,ADRDISP);
      CALL EMITRR(BCR,"0F"B4, BRCHREG, SOURCELINE() );
   END;

 /*  <RETURN STATEMENT> ::= RETURN <EXPRESSION>    */
   WHEN (45)
   DO;  /* EMIT A RETURN BRANCH & PASS VALUE IN REGISTER 3 */
      /* NOW FORCE IT INTO REGISTER 3 */
      TARGET_REGISTER = 3;
      IF RETURNED_TYPE = CHRTYPE THEN
         CALL FORCEDESCRIPT(MPP1);
      ELSE
         CALL FORCEACCUMULATOR(MPP1);
      TARGET_REGISTER = -1;
      IF REG(MPP1) ^= 3 THEN CALL EMITRR("18"B4, '3'B4, REG(MPP1), SOURCELINE() );
      CALL FINDADDRESS(RTNADR);
      CALL EMITRX(LOAD, BRCHREG, 0, BIT(BINARY(ADREG, 8)), ADRDISP);
      CALL EMITRR(BCR, "0F"B4, BRCHREG, SOURCELINE() );
      CALL CLEARREGS;
   END;

 /*  <CALL STATEMENT> ::= CALL <VARIABLE>    */
   WHEN (46)
   DO;
      CALL FORCEACCUMULATOR(SP);
      CALL CLEARREGS;
   END;

 /*  <GO TO STATEMENT> ::= <GO TO> <IDENTIFIER>    */
   WHEN (47)
   DO;
      CALL ID_LOOKUP(SP);
      J = FIXL(SP);
      IF J < 0 THEN          /*  1ST OCURRANCE OF THE LABEL */
         DO;
            CALL EMITDATAWORD(0);      /* SPACE FOR FIXUP */
            J = ENTER (VAR(SP), FORWARDTYPE, DP-4, FIXL(SP));
            SYTCO(J) = 1;
         END;
      IF SYTYPE(J) = LABELTYPE THEN
         CALL BRANCH_BD("0F"B4, SYBASE(J), SYDISP(J));
      ELSE IF SYTYPE(J) = FORWARDTYPE THEN
         DO;
            CALL EMITRX(LOAD,BRCHREG,0,SYBASE(J),SYDISP(J));
            CALL EMITRX(BC,"0F"B4, BRCHREG, PBR, 0);
         END;
      ELSE
         DO;
            CALL ERROR('TARGET OF GO TO IS NOT A LABEL',0);
            CALL EMITRX(BC,"0F"B4,0,SYBASE(J),SYDISP(J));
         END;
   END;

 /*  <GO TO> ::= GO TO    */
   WHEN (48) ;
 /*  <GO TO> ::= GOTO    */
   WHEN (49) ;
 /*  <DECLARATION STATEMENT> ::= DECLARE <DECLARATION ELEMENT>    */
   WHEN (50) ;

 /*  <DECLARATION STATEMENT> ::= <DECLARATION STATEMENT> , <DECLARATION ELEMENT>
          */
   WHEN (51) ;

 /*  <DECLARATION ELEMENT> ::= <TYPE DECLARATION>    */
   WHEN (52)
   DO;
      IF TYPE(MP) = CHRTYPE THEN
         DSP = NEWDSP ;
      ELSE
         DO;
            DP = NEWDP ;
            CALL CHECKBASES ;
         END;
   END;

 /*  <DECLARATION ELEMENT> ::= <IDENTIFIER> LITERALLY <STRING>    */
   WHEN (53)
      IF TOP_MACRO >= MACRO_LIMIT THEN
         CALL ERROR('MACRO TABLE OVERFLOW',1);
      ELSE
         DO;
ON SUBSCRIPTRANGE SNAP BEGIN;
PUT SKIP LIST (I, J, K, L, TOP_MACRO);
GO TO RVTF;
END;
            TOP_MACRO = TOP_MACRO + 1;
            I = LENGTH(VAR(MP));
            J = MACRO_INDEX(I);
            DO L = 1 TO TOP_MACRO - J;
               K = TOP_MACRO - L;
               MACRO_NAME(K+1) = MACRO_NAME(K);
               MACRO_TEXT(K+1) = MACRO_TEXT(K);
            END;
            MACRO_NAME(J) = VAR(MP);
            MACRO_TEXT(J) = VAR(SP);
            DO J = I TO 255;
               MACRO_INDEX(J) = MACRO_INDEX(J)+1;
            END;
RVTF:REVERT SUBSCRIPTRANGE;
         END;

 /*  <TYPE DECLARATION> ::= <IDENTIFIER SPECIFICATION> <TYPE>    */
   WHEN (54) CALL TDECLARE(0);

 /*  <TYPE DECLARATION> ::= <BOUND HEAD> <NUMBER> ) <TYPE>    */
   WHEN (55) CALL TDECLARE(FIXV(MPP1));

 /*  <TYPE DECLARATION> ::= <TYPE DECLARATION> <INITIAL LIST>    */
   WHEN (56) ;

 /*  <TYPE> ::= FIXED    */
   WHEN (57) TYPE(MP) = FIXEDTYPE ;

 /*  <TYPE> ::= CHARACTER    */
   WHEN (58) TYPE(MP) = CHRTYPE ;

 /*  <TYPE> ::= LABEL    */
   WHEN (59) TYPE(MP) = FORWARDTYPE ;

 /*  <TYPE> ::= <BIT HEAD> <NUMBER> )    */
   WHEN (60)
      IF FIXV(MPP1) <= 8 THEN TYPE(MP) = BYTETYPE;
      ELSE IF FIXV(MPP1) <= 16 THEN TYPE(MP) = HALFWORD;
      ELSE IF FIXV(MPP1) <= 32 THEN TYPE(MP) = FIXEDTYPE;
      ELSE TYPE(MP) = CHRTYPE;

 /*  <BIT HEAD> ::= BIT (   */
   WHEN (61) ;

 /*  <BOUND HEAD> ::= <IDENTIFIER SPECIFICATION> (   */
   WHEN (62) ;

 /*  <IDENTIFIER SPECIFICATION> ::= <IDENTIFIER>    */
   WHEN (63)
   DO;
      INX(MP) = '01'B4;
      I = FIXL(MP);
      FIXL(MP) = CASEP;
      IF CASEP >= CASELIMIT THEN
         CALL ERROR(DCLRM,1);
      ELSE
         CASEP = CASEP + 1;
      CASESTACK(CASEP) = ENTER (VAR(MP), 0, 0, I);
   END;

 /*  <IDENTIFIER SPECIFICATION> ::= <IDENTIFIER LIST> <IDENTIFIER> )    */
   WHEN (64)
   DO;
      INX(MP) = BIT(BINARY(INX(MP) + 1, 8));
      IF CASEP >= CASELIMIT THEN
         CALL ERROR(DCLRM, 1);
      ELSE
         CASEP = CASEP + 1;
      CASESTACK(CASEP) = ENTER (VAR(MPP1), 0, 0, FIXL(MPP1));
   END;

 /*  <IDENTIFIER LIST> ::= (   */
   WHEN (65)
   DO;
      INX(MP) = '00'B4;
      FIXL(MP) = CASEP;
   END;

 /*  <IDENTIFIER LIST> ::= <IDENTIFIER LIST> <IDENTIFIER> ,    */
   WHEN (66)
   DO;
      INX(MP) = BIT(BINARY(INX(MP) + 1, 8));
      IF CASEP >= CASELIMIT THEN
         CALL ERROR(DCLRM, 1);
      ELSE
         CASEP = CASEP + 1;
      CASESTACK(CASEP) = ENTER (VAR(MPP1), 0, 0, FIXL(MPP1));
   END;

 /*  <INITIAL LIST> ::= <INITIAL HEAD> <CONSTANT> )    */
   WHEN (67) CALL SETINIT ;

 /*  <INITIAL HEAD> ::= INITIAL (   */
   WHEN (68)
   IF INX(MP-1) = 1 THEN
      ITYPE = TYPE(MP-1);    /*  INFORMATION FROM  <TYPE DECLARATION>  */
   ELSE
      DO;
         CALL ERROR('INITIAL MAY NOT BE USED WITH IDENTIFIER LIST',0);
         ITYPE = 0;
      END;


 /*  <INITIAL HEAD> ::= <INITIAL HEAD> <CONSTANT> ,    */
   WHEN (69) CALL SETINIT;

 /*  <ASSIGNMENT> ::= <VARIABLE> <REPLACE> <EXPRESSION>    */
   WHEN (70) CALL GENSTORE(MP,SP);

 /*  <ASSIGNMENT> ::= <LEFT PART> <ASSIGNMENT>    */
   WHEN (71) CALL GENSTORE(MP,SP);

 /*  <REPLACE> ::= =    */
   WHEN (72) ;

 /*  <LEFT PART> ::= <VARIABLE> ,    */
   WHEN (73) ;

 /*  <EXPRESSION> ::= <LOGICAL FACTOR>    */
   WHEN (74) ;

 /*  <EXPRESSION> ::= <EXPRESSION> | <LOGICAL FACTOR>    */
   /* "16" = OR, "56" = O */
   WHEN (75) CALL ARITHEMIT("16"B4);

 /*  <LOGICAL FACTOR> ::= <LOGICAL SECONDARY>    */
   WHEN (76) ;

 /*  <LOGICAL FACTOR> ::= <LOGICAL FACTOR> & <LOGICAL SECONDARY>    */
   /* "14" = NR, "54" = N */
   WHEN (77) CALL ARITHEMIT("14"B4);

 /*  <LOGICAL SECONDARY> ::= <LOGICAL PRIMARY>    */
   WHEN (78) IF TYPE(MP) = CONDITION THEN CALL CONDTOREG(MP, REG(MP));

 /*  <LOGICAL SECONDARY> ::= ^ <LOGICAL PRIMARY>    */
   WHEN (79)
   DO;
      CALL MOVESTACKS (SP, MP);
      IF TYPE(MP) = CONDITION THEN
         CALL CONDTOREG (MP, "0E"B4 - REG(MP));
      ELSE
         DO;
            CALL FORCEACCUMULATOR (MP);
              /* "57" = X */
            CALL EMITRX ("57"B4, REG(MP), 0, DBR, COMPLOC);
         END;
   END;

 /*  <LOGICAL PRIMARY> ::= <STRING EXPRESSION>    */
   WHEN (80) ;

   /*              CONDITION CODES     MASK
                   0  OPERANDS EQUAL   BIT 8
                   1  FIRST OPERAND LO BIT 9
                   2  FIRST OPERAND HI BIT 10                                 */

 /*  <LOGICAL PRIMARY> ::= <STRING EXPRESSION> <RELATION> <STRING EXPRESSION>
         */
   WHEN (81)
   DO;
      /* THIS HAS TO OCCUPY LESS THAN 414 BYTES TO BREAK EVEN */
      I=0;
      IF TYPE(SP)=CONSTANT THEN IF TYPE(MP)=VARIABLE THEN IF SYTYPE(FIXL(MP))=
         BYTETYPE THEN I=1; /* ECONOMISER */
      IF I ^= 0 THEN
         DO;
            I = SYBASE(FIXL(MP)); J = SYDISP(FIXL(MP));
            IF INX(MP)=16 THEN /* THE SUBSCRIPT WAS A CONSTANT */
               DO; J = J + PPSAVE(MP); INX(MP)=0; END;
            IF INX(MP)^=0 THEN
               DO; /* SUBSCRIPTED BYTETYPE VARIABLE */
                  IF I>0 THEN /* EXCEPT FOR COREBYTE & COREWORD */
                     CALL EMITRR("1A"B4, INX(MP), I, SOURCELINE() );
                  I = INX(MP);
                  BASES(I) = AVAIL;
               END;
            CALL EMITRX("95"B4, 0, FIXV(SP), I, J); /* CLI */
         END;
      ELSE
         DO;
            CALL ARITHEMIT(CMPRR);
            BASES(REG(MP)) = AVAIL;
         END;
      REG(MP) = REG(MPP1);
      TYPE(MP) = CONDITION;
   END;

 /*  <RELATION> ::= =    */
   WHEN (82) REG(MP) = 6;

 /*  <RELATION> ::= <    */
   WHEN (83) REG(MP) = 10;

 /*  <RELATION> ::= >    */
   WHEN (84) REG(MP) = 12;

 /*  <RELATION> ::= ^ =    */
   WHEN (85) REG(MP) = 8;

 /*  <RELATION> ::= ^ <    */
   WHEN (86) REG(MP) = 4;

 /*  <RELATION> ::= ^ >    */
   WHEN (87) REG(MP) = 2;

 /*  <RELATION> ::= < =    */
   WHEN (88) REG(MP) = 2;

 /*  <RELATION> ::= > =    */
   WHEN (89) REG(MP) = 4;

 /*  <STRING EXPRESSION> ::= <ARITHMETIC EXPRESSION>    */
   WHEN (90) ;

 /*  <STRING EXPRESSION> ::= <STRING EXPRESSION> || <ARITHMETIC EXPRESSION>
         */
   WHEN (91)
   DO; /* CATENATE TWO STRINGS */
      CALL FORCEDESCRIPT(MP);
      CALL EMITRX(STORE,REG(MP),0,A1,A2);
      BASES(REG(MP)) = AVAIL;
      CALL FORCEACCUMULATOR(SP);
      IF TYPE(SP)^=DESCRIPT THEN
         DO;
            CALL EMITRX(STORE, REG(SP), 0, DBR, STRN);
            BASES(REG(SP)) = AVAIL;
            CALL CALLSUB(0,CATNUMNTRY,3,MP); /* CONVERT AND CATENATE */
         END;
        ELSE
         DO;
      CALL EMITRX(STORE,REG(SP),0,B1,B2);
      BASES(REG(SP)) = AVAIL;
      CALL CALLSUB(0, CATENTRY, 3, MP);
      /* ASSUME CATENATE IS IN THE 1ST PAGE */
         END;

      TYPE(MP) = DESCRIPT;
   END;

 /*  <ARITHMETIC EXPRESSION> ::= <TERM>    */
   WHEN (92) ;
 /*  <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> + <TERM>    */
   /* "1A" = AR, "5A" = A  */
   WHEN (93) CALL ARITHEMIT("1A"B4);

 /*  <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> - <TERM>    */
   /* "1B" = SR, "5B" = S */
   WHEN (94) CALL ARITHEMIT("1B"B4);

 /*  <ARITHMETIC EXPRESSION> ::= + <TERM>    */
   WHEN (95) CALL MOVESTACKS(MPP1,MP);

 /*  <ARITHMETIC EXPRESSION> ::= - <TERM>    */
   WHEN (96)
   DO;
      CALL MOVESTACKS(MPP1, MP);
      IF TYPE(MP) = CONSTANT THEN FIXV(MP) = - FIXV(MP);
      ELSE
         DO;
            CALL FORCEACCUMULATOR(MP);
            CALL EMITRR("13"B4, REG(MP), REG(MP), SOURCELINE() );  /* LCR = COMPLEMENT */
         END;
   END;

 /*  <TERM> ::= <PRIMARY>    */
   WHEN (97) ;

 /*  <TERM> ::= <TERM> * <PRIMARY>    */
   /* "1C" = MR, "5C" = M */
   WHEN (98)
   IF TYPE(MP)=CONSTANT & FIXV(MP)<32767 & FIXV(MP)>-32768 THEN /* MH can be used.*/
      DO;   /* REGISTER PROBLEM IS SIMPLER WITH MH */
         CALL FORCEACCUMULATOR(SP);
         CALL EMITCONSTANT(ISLL(FIXV(MP), 16)); /* PLACE CONST. IN 1ST HALF */
         CALL EMITRX("4C"B4, REG(SP), 0, BIT(BINARY(ADREG, 8)), ADRDISP);  /* MH */
         REG(MP) = REG(SP);
         BASES(REG(MP)),
         TYPE(MP) = ACCUMULATOR;
      END;
   ELSE /* M must be used. */
   DO;
      /* TRIES REG 3 IF REG 1 IS IN USE */
      IF BASES(1)^=AVAIL THEN TARGET_REGISTER = 3;
      CALL FORCEACCUMULATOR(MP); /* FIRST OPERAND */
      TARGET_REGISTER=-1;
      REG1=REG(MP);
      IF (IAND(REG1, 1) ^= 0) & (BASES(REG1-1))=AVAIL THEN
        DO; /* REG1 IS ODD-NUMBERED WITH A PREVIOUS EVEN-NUMBERED REGISTER FREE */
            REG(MP)= BIT(BINARY(REG1-1, 8));
            CALL ARITHEMIT("1C"B4); /* MULTIPLY */
        END;
       ELSE
        DO; /* REG1 IS EVEN-NUMBERED, OR IS 3 WITH REG 2 IN USE */
            CALL FORCEACCUMULATOR(SP); /* SECOND OPERAND */
            IF REG(SP)=1 THEN REG2 =1;     /* CAUSES  MR  0,REG(MP) */
                         ELSE
                          DO;          /* CAUSES  MR  2,2       */
                             REG2 = 3; REG1 = 2;
                          END;
            CALL EMITRR("1C"B4, REG2-1, REG1, SOURCELINE() );
            BASES(REG1),BASES(REG(SP))=AVAIL;
            REG1 = REG2;
        END;
      REG(MP) = REG1;
      BASES(REG1)=ACCUMULATOR;
   END;

 /*  <TERM> ::= <TERM> / <PRIMARY>    */
   WHEN (99) CALL DIVIDE_CODE(1);
   /*  DIVIDE IS EVEN FUNNIER THAN MULTIPLY  */

 /*  <TERM> ::= <TERM> MOD <PRIMARY>    */
   WHEN (100)
      DO;
         CALL DIVIDE_CODE(0);
      END;

 /*  <PRIMARY> ::= <CONSTANT>    */
   WHEN (101) ;

 /*  <PRIMARY> ::= <VARIABLE>    */
   WHEN (102)
      IF FIXV(MP) = 3 THEN   /*  FINISH OFF THE FUNCTION  BYTE        */
         IF CNT(MP) = 1 THEN
            DO;
               IF TYPE(MP) = CHRTYPE THEN
                  DO;
                     TYPE(MP) = CONSTANT;
                     FIXV(MP) = BYTE(VAR(MP));
                  END;
               ELSE
                  DO;
                     REG1 = FINDAC();
                     CALL EMITRR("1B"B4, REG1, REG1, SOURCELINE() ); /*  SR    REG1,REG1 */
                     CALL EMITRX("43"B4, REG1, 0, REG(MP), 0);
                                                 /*  IC               */
                     BASES(REG(MP)) = AVAIL;
                     REG(MP) = REG1;
                     TYPE(MP) = ACCUMULATOR;
                  END;
            END;
         ELSE IF CNT(MP) = 2 THEN
            DO;
               REG1 = INX(MP);
               CALL EMITRX("43"B4, REG1, REG1, REG(MP), 0);
               BASES(REG(MP)) = AVAIL;
               REG(MP) = REG1;
               TYPE(MP) = ACCUMULATOR;
            END;

 /*  <PRIMARY> ::= ( <EXPRESSION> )    */
   WHEN (103) CALL MOVESTACKS(MPP1, MP);

 /*  <VARIABLE> ::= <IDENTIFIER>    */
   WHEN (104)
   DO;      /* FIND THE IDENTIFIER IN THE SYMBOL TABLE */
      CALL ID_LOOKUP(MP);
      IF FIXL(MP) = -1 THEN
         CALL UNDECLARED_ID(MP);
   END;

 /*  <VARIABLE> ::= <SUBSCRIPT HEAD> <EXPRESSION> )    */
   WHEN (105)
   DO;  /* EITHER A PROCEDURE CALL OR ARRAY OR BUILT IN FUNCTION */
      CNT(MP) = CNT(MP) + 1;
      I = FIXV(MP);

      IF I < 6 THEN
      SELECT (I);

         /* CASE  0  */

         WHEN (0)
         DO;      /* SUBS | CALL */
            IF SYTYPE(FIXL(MP)) = LABELTYPE |
               SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE  THEN
               CALL STUFF_PARAMETER;
            ELSE
               DO;      /* SUBSCRIPTED VARIABLE */
                IF TYPE(MPP1)=CONSTANT THEN
                    /* THE SUBSCRIPT IS A CONSTANT */
                    DO;
                  I = SYTYPE(FIXL(MP));
                             IF I=BYTETYPE THEN J=FIXV(MPP1);
                             ELSE IF I=HALFWORD THEN J = ISLL(FIXV(MPP1),1);
                             ELSE J = ISLL(FIXV(MPP1), 2);
                       I = SYDISP(FIXL(MP))+J;
                       /* FIND THE VALUE OF THE DISPLACEMENT */
                        END;
                  ELSE I = -1;
                       /* NOTE: NO ACTION FOR A ZERO SUBSCRIPT */
                       IF (I>=0) & (I<=4095) THEN
                          DO;
                             PPSAVE(MP) = J;  REG(MPP1) = 16;
                          END;
                       ELSE
                          DO;
                             PPSAVE(MP)=0;
                             CALL FORCEACCUMULATOR(MPP1);
                          END;
                            INX(MP) = REG(MPP1);
                  IF CNT(MP) > 1 THEN
                     CALL ERROR ('MULTIPLE SUBSCRIPTS NOT ALLOWED', 0);
               END;
         END;

         /* CASE  1  */

         WHEN (1)
         DO;  /* BUILT IN FUNCTION: LENGTH */
                /* SAVE THE PP FOR CODE OPTIMIZING  LENGTH(X)=CONSTANT */
                I = PP;
            IF TYPE(MPP1)=VARIABLE THEN IF SYTYPE(FIXL(MPP1))= CHRTYPE THEN
            /* SAVE THE PP FOR ECONOMISER */
               J = ISLL(INX(MPP1), 16);
                J = IOR (J,   ISLL(SYBASE(FIXL(MPP1)),12),   SYDISP(FIXL(MPP1)));
               IF INX(MPP1)=16 THEN J = J + PPSAVE(MPP1);
            CALL FORCEDESCRIPT (MPP1);
            LENGTHPP2 = PP; /* SAVE FOR OPTIMISING */
            CALL EMITRX ("88"B4, REG(MPP1), 0, 0, 1); /* SRL  REG(MP),1 */
            CALL EMITRR ("06"B4, REG(MPP1), 0, SOURCELINE() );
            CALL EMITRX ("8A"B4, REG(MPP1), 0, 0,23); /* SRA  REG(MP),23 */
            /* ADD 1,GIVING TRUE LENGTH */
            CALL EMITRX("5A"B4, REG(MPP1), 0, DBR, TRUELOC);
            IF REG(MPP1)=0 THEN
               DO;
                  REG(MPP1) = FINDAC();
                  CALL EMITRR("18"B4, REG(MPP1), 0, SOURCELINE() );
                  BASES(REG(MPP1)) = ACCUMULATOR;
               END;
            REG(MP) = REG(MPP1);  /* RECORD CONTAINING ACCUMULATOR */
            TYPE(MP) = ACCUMULATOR;
            LENGTHPP = I;
                SAVEADR = J;
         END;

         /* CASE  2  */

         /* BUILT-IN FUNCTION SUBSTR */
         WHEN (2)
         DO;
            IF CNT(MP) = 2 THEN
               DO;
                  IF TYPE(MPP1) = CONSTANT THEN
                     DO;
                        CALL EMITCONSTANT (ISLL(FIXV(MPP1), 24) - FIXV(MPP1));
                        CALL EMITRX ("5F"B4, REG(MP), 0, ADREG, ADRDISP);
                     END;
                  ELSE
                     DO;
                        CALL FORCEACCUMULATOR (MPP1);
                        CALL EMITRR ("1E"B4, REG(MP), REG(MPP1), SOURCELINE() ); /* ALR BASE */
                        CALL EMITRX ("89"B4, REG(MPP1), 0, 0, 24);
                        CALL EMITRR ("1F"B4, REG(MP), REG(MPP1), SOURCELINE() );
                        BASES(REG(MPP1)) = AVAIL;
                     END;
                  I = PP;
                  CALL BRANCH (1, 0);     /* WE MAY NOW HAVE NEGATIVE LENGTH */
                  CALL EMITRR ("1B"B4, REG(MP), REG(MP), SOURCELINE() );  /* NULL DESCRIPTOR */
                  CALL FIXBFW (I, PP);
               END;
            ELSE
               DO;         /* THREE ARGUMENTS */
                  CALL EMITRX (LA, REG(MP), INX(MP), REG(MP), PPSAVE(MP));
                  BASES(INX(MP)) = AVAIL;
                  IF TYPE(MPP1) ^= CONSTANT THEN
                     DO;
                        CALL FORCEACCUMULATOR (MPP1);
                        CALL EMITRR ("06"B4, REG(MPP1), 0, SOURCELINE() );
                                /* DECREMENT LENGTH BY 1  */
                        CALL EMITRX ("89"B4, REG(MPP1), 0, 0, 24);
                        CALL EMITRR ("16"B4, REG(MP), REG(MPP1), SOURCELINE() );
                           /* | INTO D */
                        BASES(REG(MPP1)) = AVAIL;
                     END;
                  ELSE
                     DO;
                        CALL EMITCONSTANT (ISLL(FIXV(MPP1)-1, 24));
                        CALL EMITRX ("56"B4, REG(MP), 0, ADREG, ADRDISP);
                     END;
               END;
            TYPE(MP) = DESCRIPT;
         END;

         /* CASE  3  */

         WHEN (3)
         DO;      /* BUILT IN FUNCTION BYTE */
            IF CNT(MP) = 1 THEN
               DO;
                  IF TYPE(MPP1) = CHRTYPE THEN
                     DO;
                        TYPE(MP) = CHRTYPE;
                        VAR(MP) = VAR(MPP1);
                     END;
                  ELSE
                     DO;
                        CALL FORCEDESCRIPT(MPP1);
                        IF REG(MPP1) = 0 THEN
                           DO;
                              REG(MP) = FINDAC();
                              CALL EMITRR("18"B4, REG(MP), 0, SOURCELINE() );
                                                 /*  LR    REG(MP),0  */
                           END;
                        ELSE
                           REG(MP) = REG(MPP1);
                        TYPE(MP) = DESCRIPT;
                        INX(MP) = 0;
                    END;
               END;
            ELSE IF CNT(MP) = 2 THEN
               DO;
                  CALL FORCEACCUMULATOR(MPP1);
                  INX(MP) = REG(MPP1);
               END;
            ELSE
               CALL ERROR('BYTE CALLED WITH MORE THAN TWO ARGUMENTS',0);
         END;

         /* CASE  4  */

         WHEN (4) CALL SHIFT_CODE("89"B4);        /*  SLL  */

         /* CASE  5  */

         WHEN (5) CALL SHIFT_CODE("88"B4);        /*  SRL  */

      END;     /* OF SELECT STATEMENT */

      ELSE IF I = 10 THEN
         CALL EMIT_INLINE;
      ELSE IF I = 19 THEN    /*  BUILTIN  FUNCTION  ADDR   */
         DO;
            REG(MP) = FINDAC();
            CALL FORCE_ADDRESS(MPP1,REG(MP));
            TYPE(MP) = ACCUMULATOR;
         END;
      ELSE
         DO;
            CALL FORCEACCUMULATOR (MPP1);
            IF CNT(MP) = 1 THEN REG(MP) = REG(MPP1);
            ELSE INX(MP) = REG(MPP1);
         END;

   END;     /* OF PRODUCTION */

 /*  <SUBSCRIPT HEAD> ::= <IDENTIFIER> (   */
   WHEN (106)
   DO;
      CALL ID_LOOKUP(MP);
      IF FIXL(MP) < 0 THEN
         CALL UNDECLARED_ID(MP);
   END;

 /*  <SUBSCRIPT HEAD> ::= <SUBSCRIPT HEAD> <EXPRESSION> ,    */
   WHEN (107)
   DO;      /* BUILT IN FUNCTION OR PROCEDURE CALL */
      CNT(MP) = CNT(MP) + 1;
      IF FIXV(MP) = 0 THEN
         DO;      /* ^ BUILT IN FUNCTION */
            IF SYTYPE(FIXL(MP)) = LABELTYPE |
               SYTYPE(FIXL(MP)) = CHAR_PROC_TYPE  THEN
               CALL STUFF_PARAMETER;
         END;
      ELSE IF FIXV(MP) = 2 | FIXV(MP) = 3 THEN
         DO;      /* SUBSTR OR BYTE */
            IF CNT(MP) = 1 THEN
               DO;
                  CALL FORCEDESCRIPT (MPP1);
                  IF REG(MPP1) = 0 THEN
                     DO;
                        REG(MP) = FINDAC();
                        CALL EMITRR ("18"B4, REG(MP), 0, SOURCELINE() );
                     END;
                  ELSE REG(MP) = REG(MPP1);
               END;
            ELSE IF CNT(MP) = 2 THEN
               DO;
                  IF TYPE(MPP1) = CONSTANT THEN PPSAVE(MP) = FIXV(MPP1);
                  ELSE
                     DO;
                        CALL FORCEACCUMULATOR (MPP1);
                        INX(MP) = REG(MPP1);
                        PPSAVE(MP) = 0;
                     END;
               END;
            ELSE CALL ERROR ('TOO MANY ARGUMENTS TO SUBSTR or BYTE');
         END;
      ELSE IF FIXV(MP) = 4 | FIXV(MP) = 5 THEN
         DO;  /*  ISRL  |  ISLL  */
            CALL FORCEACCUMULATOR(MPP1);
            REG(MP) = REG(MPP1);
         END;
      ELSE IF FIXV(MP) = 10 THEN
         CALL EMIT_INLINE;
      ELSE IF FIXV(MP) >= 8 THEN
         DO;      /* SOME SORT OF MONITOR CALL */
            CALL FORCEACCUMULATOR (MPP1);
            IF CNT(MP) = 1 THEN REG(MP) = REG(MPP1);
            ELSE CALL ERROR ('TOO MANY ARGUMENTS FOR ' || SYT(FIXL(MP)));
         END;
      ELSE;      /* RESERVED FOR OTHER BUILT IN FUNCTIONS */
   END;

 /*  <CONSTANT> ::= <STRING>    */
   WHEN (108) TYPE(MP) = CHRTYPE;

 /*  <CONSTANT> ::= <NUMBER>    */
   WHEN (109) TYPE(MP) = CONSTANT;

   END;  /* OF CASE SELECTION ON PRODUCTION NUMBER */
END SYNTHESIZE;




  /*              SYNTACTIC PARSING FUNCTIONS                              */


RIGHT_CONFLICT:
   PROCEDURE (LEFT) RETURNS (BIT(1) ALIGNED);
      DECLARE LEFT UNSIGNED FIXED BINARY(8);

      /*  THIS PROCEDURE IS TRUE IF TOKEN IS NOT A LEGAL RIGHT CONTEXT OF LEFT*/
      RETURN (SUBSTR(C1(LEFT), TOKEN+TOKEN+1, 2) = '00'B);
   END RIGHT_CONFLICT;


RECOVER:
   PROCEDURE;

PUT SKIP LIST ('ENTERED RECOVER*********************************');
      /* IF THIS IS THE SECOND SUCCESSIVE CALL TO RECOVER, DISCARD ONE SYMBOL */
      IF ^ FAILSOFT THEN CALL SCAN;
      FAILSOFT = FALSE;
      DO WHILE (^ STOPIT(TOKEN));
         CALL SCAN;  /* TO FIND SOMETHING SOLID IN THE TEXT  */
/*PUT SKIP LIST ('RECOVER, after SCAN: Token=', Token, 'BCD=' || BCD,
   'NUMBER_VALUE=', Number_Value); */
      END;
      DO WHILE (RIGHT_CONFLICT (PARSE_STACK(SP)) );
         IF SP > 2 THEN SP = SP - 1;  /* AND IN THE STACK  */
         ELSE CALL SCAN;  /* BUT DON'T GO TOO FAR  */
/*PUT SKIP LIST ('RECOVER 2, after SCAN: Token=', Token, 'BCD=' || BCD,
   'NUMBER_VALUE=', Number_Value); */
      END;
      PUT SKIP EDIT ( 'RESUME:', SUBSTR(POINTER, TEXT_LIMIT+LB-CP+MARGIN_CHOP+7+1)) (A);
   END RECOVER;

STACKING:
   PROCEDURE RETURNS (BIT(1) ALIGNED);  /* STACKING DECISION FUNCTION */

      COUNT#STACK = COUNT#STACK + 1;
      DO FOREVER;    /* UNTIL RETURN  */
/*PUT SKIP LIST ('IN STACKING: TOKEN=', Token, ' parse_stack(sp)=', parse_stack(sp));
PUT SKIP LIST ('IN STACKING WITH ', SUBSTR(C1(PARSE_STACK(SP)), TOKEN+TOKEN+1, 2));
put skip list ('PARSE_STACK='); */
/*DO I = 0 TO SP;
   PUT EDIT(PARSE_STACK(I)) (F(6));
END; */
         SELECT (SUBSTR(C1(PARSE_STACK(SP)), TOKEN+TOKEN+1, 2));

            /*  CASE 0  */
            WHEN ('00'B)
            DO;    /* ILLEGAL SYMBOL PAIR  */
               CALL ERROR('ILLEGAL SYMBOL PAIR: ' || V(PARSE_STACK(SP)) || X1 ||
                  V(TOKEN), 1);
               CALL STACK_DUMP;
               CALL RECOVER;
            END;

            /*  CASE 1  */

            WHEN ('01'B) RETURN (TRUE);      /*  STACK TOKEN  */

            /*  CASE 2  */

            WHEN ('10'B) RETURN (FALSE);     /* DON'T STACK IT YET  */

            /*  CASE 3  */

            WHEN ('11'B)
            DO;      /* MUST CHECK TRIPLES  */
               J = ISLL(PARSE_STACK(SP-1), 16) + ISLL(PARSE_STACK(SP), 8) + TOKEN;
               I = -1;  K = NC1TRIPLES + 1;  /* BINARY SEARCH OF TRIPLES  */
               DO WHILE (I + 1 < K);
                  L = ISRL(I+K, 1);
                  IF C1TRIPLES(L) > J THEN K = L;
                  ELSE IF C1TRIPLES(L) < J THEN I = L;
                  ELSE RETURN (TRUE);  /* IT IS A VALID TRIPLE  */
               END;
               RETURN (FALSE);
            END;

         END;    /* OF SELECT  */
      END;   /*  OF DO FOREVER */
   END STACKING;

PR_OK:
   PROCEDURE(PRD) RETURNS (BIT(1) ALIGNED);
      /* DECISION PROCEDURE FOR CONTEXT CHECK OF EQUAL OR IMBEDDED RIGHT PARTS*/
      DECLARE (H, I, J, PRD) FIXED BINARY (31);

      SELECT (CONTEXT_CASE(PRD) );

         /*  CASE 0 -- NO CHECK REQUIRED  */

         WHEN (0) RETURN (TRUE);

         /*  CASE 1 -- RIGHT CONTEXT CHECK  */

         WHEN (1) RETURN (^ RIGHT_CONFLICT (HDTB(PRD)) );

         /*  CASE 2 -- LEFT CONTEXT CHECK  */

         WHEN (2)
         DO;
            H = HDTB(PRD) - NT;
            I = PARSE_STACK(SP - PRLENGTH(PRD));
            DO J = LEFT_INDEX(H-1) TO LEFT_INDEX(H) - 1;
               IF LEFT_CONTEXT(J) = I THEN RETURN (TRUE);
            END;
            RETURN (FALSE);
         END;

         /*  CASE 3 -- CHECK TRIPLES  */

          WHEN (3)
         DO;
            H = HDTB(PRD) - NT;
            I = ISLL(PARSE_STACK(SP - PRLENGTH(PRD)), 8) + TOKEN;
            DO J = TRIPLE_INDEX(H-1) TO TRIPLE_INDEX(H) - 1;
               IF CONTEXT_TRIPLE(J) = I THEN RETURN (TRUE);
            END;
            RETURN (FALSE);
         END;

      END;  /* OF SELECT  */
   END PR_OK;


  /*                     ANALYSIS ALGORITHM                                  */



REDUCE:
   PROCEDURE;
      DECLARE (I, J, PRD) FIXED BINARY (31);
      DECLARE (TOK1, TOK2, TOK3, TOK4) UNSIGNED FIXED BINARY(8);

      TOK1, TOK2, TOK3, TOK4 = 0;
      IF SP >= 1 THEN TOK4 = PARSE_STACK(SP-1);
      IF SP >= 2 THEN TOK3 = PARSE_STACK(SP-2);
      IF SP >= 3 THEN TOK2 = PARSE_STACK(SP-3);
      IF SP >= 4 THEN TOK1 = PARSE_STACK(SP-4);
      /* PACK THE TOP 4 TOKENS ON THE PARSE STACK INTO ONE WORD (J) */
      J = ISLL(TOK1, 8) + TOK2;
      J = ISLL(J, 16) + ISLL(TOK3, 8) + TOK4;
/*PUT SKIP LIST ('TOS IS:'); */
/*PUT SKIP EDIT (TOK1, TOK2, TOK3, TOK4, PARSE_STACK(SP))(F(8)); */
/*PUT SKIP LIST ('PRODUCTIONS EXAMINED ARE:'); */

      /* Now search the production tables for a match with the top n tokens (1 <= n <= 4). */
      DO PRD = PR_INDEX(PARSE_STACK(SP)-1) TO PR_INDEX(PARSE_STACK(SP)) - 1;
TOK4 = IAND(PRTB(PRD), 255);
TOK3 = IAND(ISRL(PRTB(PRD), 8), 255);
TOK2 = IAND(ISRL(PRTB(PRD), 16), 255);
TOK1 = IAND(ISRL(PRTB(PRD), 24), 255);
/*PUT SKIP EDIT (TOK1, TOK2, TOK3, TOK4, PARSE_STACK(SP))(F(8)); */
/*PUT      EDIT (J, PRTB(PRD), PRMASK(PRLENGTH(PRD))) (F(11)); */

         IF IAND(PRMASK(PRLENGTH(PRD)), J) = PRTB(PRD) THEN
            IF PR_OK(PRD) THEN
            DO;  /* AN ALLOWED REDUCTION */
               MP = SP - PRLENGTH(PRD) + 1; MPP1 = MP + 1;
               CALL SYNTHESIZE(PRDTB(PRD));
               VAR(MPP1+1), VAR(MPP1) = ''; /* PURGE UNNEEDED STRINGS */
               SP = MP;
               PARSE_STACK(SP) = HDTB(PRD); /* Replace the top n tokens with the */
                                                    /* corresponding production. */
               RETURN;
            END;
      END;

      /* LOOK UP HAS FAILED, ERROR CONDITION */
/*      IF ERROR_COUNT <= 20 THEN */
         DO;
            CALL ERROR('CANNOT MATCH A PRODUCTION.  NO PRODUCTION IS APPLICABLE',1);
            CALL STACK_DUMP;
         END;
      FAILSOFT = FALSE;
      CALL RECOVER;
   END REDUCE;

COMPILATION_LOOP:
   PROCEDURE;

      COMPILING = TRUE;
      DO WHILE (COMPILING);     /* ONCE AROUND FOR EACH PRODUCTION (REDUCTION)  */
         DO WHILE (STACKING());
            SP = SP + 1;
            IF SP>STACKMAX THEN STACKMAX = SP;
            IF SP = STACKSIZE THEN
               DO;
                  CALL ERROR ('STACK OVERFLOW *** COMPILATION ABORTED ***', 2);
                  RETURN;   /* THUS ABORTING COMPILATION */
               END;
            PARSE_STACK(SP) = TOKEN;
            VAR(SP) = BCD;
            FIXV(SP) = NUMBER_VALUE;
            FIXL(SP) = CARD_COUNT;
            PPSAVE(SP) = PP;
            CALL SCAN;
/* PUT SKIP LIST ('COMPILATION LOOP, after SCAN: Token=', Token, 'BCD=' || BCD, */
/*               'NUMBER_VALUE=', Number_Value); */
/* CALL STACK_DUMP; */
         END;

         CALL REDUCE;
/*CALL STACK_DUMP; */
      END;     /* OF DO WHILE COMPILING  */
   END COMPILATION_LOOP;


LOADER:
   PROCEDURE;

      /*  WRITE OUT A LOAD FILE OF COMPILED CODE & DATA
         ASSUMES CODE ON  FILE(CODEFILE, J)    J = 0 TO CODEMAX
         ASSUMES DATA ON  FILE(DATAFILE, J)   J = 0 TO DATAMAX
         ASSUMES STRINGS ON FILE(STRINGFILE,J)
         OUTPUT  ON FILE(BINARYFILE, J)  J = 0 TO CODEMAX+DATAMAX+1
         ASSUMES THAT BINARYFILE = CODEFILE    */


      /*  PUT SOME CONTROL INFORMATION IN THE FIRST 60 BYTES OF THE
         FIRST BLOCK OF CODE.  CONSECUTIVE WORDS OF THIS CONTROL
         INFORMATION CONTAIN:

            1  # OF BYTES OF PROGRAM
            2  # OF BYTES OF DATA
            3  # OF BLOCKS OF PROGRAM
            4  # OF BLOCKS OF DATA
            5  # OF BYTES PER BLOCK
            6  # OF BYTES ACTUALLY FILLED IN THE LAST CODE BLOCK
            7  # OF BYTES ACTUALLY FILLED IN THE LAST DATA BLOCK

         THE FILE IS FORMATTED:

            1  CODEMAX+1 BLOCKS OF PROGRAM
               (AND CONTROL INFORMATION AT HEAD OF FIRST BLOCK)
            2  DATAMAX+1 BLOCKS OF DATA AND STRINGS
      */

      DECLARE (I, J) FIXED BINARY(31);
      DECLARE BLOCKCNT FIXED BINARY (31);  /* CUMULATIVE BLOCK COUNTER DURING LOAD */

      CONTROL(BYTE('E')) = FALSE;
      PUT PAGE;;
      DP = BASES(SBR);
      CALL FIXWHOLEDATAWORD (BASEDATA, DP);
      DO I = 0 TO ISRL(DSP,2);
         CALL EMITDATAWORD (DESC(I));
      END;
      CALL FIXWHOLEDATAWORD(BASEDATA+4, DP);

      /* COPY COMPILED CHARACTER STRINGS TO THE PROGRAM DATA AREA */
      CHPORG = 0;
      CHPLIM = DISKBYTES;
/*      FILE(STRINGFILE,CURSBLK) = STRINGS;    /* WRITE OUT CURRENT BLOCK */
      DO JJ = 0 TO DISKBYTES-1;
         STRING_ARRAY(JJ + DISKBYTES*CURSBLK) = STRINGS(JJ);
      END;
      CURSBLK = 0;
/*      STRINGS = FILE(STRINGFILE,CURSBLK);    /* READ IN FIRST BLOCK */
      DO JJ = 0 TO DISKBYTES-1;
         STRINGS(JJ) = STRING_ARRAY(JJ);
      END;
      DO I = 0 TO CHP;
         IF I >= CHPLIM THEN
            DO;
               CURSBLK = CURSBLK + 1;
/*               STRINGS = FILE(STRINGFILE,CURSBLK);   /* READ IN NEXT BLOCK */
               DO JJ = 0 TO DISKBYTES-1;
                  STRINGS(JJ) = STRING_ARRAY(JJ + DISKBYTES*CURSBLK);
               END;
               CHPORG = CHPORG + DISKBYTES;
               CHPLIM = CHPLIM + DISKBYTES;
            END;
         CALL EMITBYTE(STRINGS(I-CHPORG));
      END;

      CALL FIXWHOLEDATAWORD(BASEDATA+8, DP);

      CALL INSERT_CODE_FIXUPS;

/*      CODE = FILE(CODEFILE,0);        /*  READ IN FIRST CODE RECORD  */
      DO JJ = 0 TO DISKBYTES-1;
         CODE(JJ) = CODE_ARRAY(JJ);
      END;

      CALL PACK (CODE, DISKBYTES*(CODEMAX+1), 0);
      CALL PACK (CODE, DISKBYTES*(DATAMAX+1), 4);
      CALL PACK (CODE, CODEMAX + 1, 8);
      CALL PACK (CODE, DATAMAX + 1, 12);
      CALL PACK (CODE, DISKBYTES, 16);
      IF SEVERE_ERRORS > 0 THEN IF ^ CONTROL(BYTE('Z')) THEN
         DO;
            CODE(60) = "07"B4;
            CODE(61) = "FC"B4;
               /* Overwrites the first instruction in the object program   */
               /* with BR 12 (which branches right back to the Monitor).   */
            PUT SKIP LIST ( '########  EXECUTION OF THIS PROGRAM WILL BE INHIBITED.' );
         END;
      J = ISLL(CODE(0), 24) + ISLL(CODE(1), 16) + ISLL(CODE(2), 8) + CODE(3);
      J = PP - J + DISKBYTES;
        /* PORTION OF THE LAST CODE RECORD THAT WAS ACTUALLY USED. */
      /* FORCES REMAINDER TO WORD BOUNDARY  */
      JJ,J = IAND(J + 3, '00FFFFFC'B4);
      CALL PACK (CODE, J, 20);
        /* PORTION OF THE LAST DATA RECORD THAT WAS ACTUALLY USED. */
      J = ISLL(CODE(4), 20) + ISLL(CODE(5), 16) + ISLL(CODE(6), 8) + CODE(7);
      CALL PACK (CODE, IAND ((DP - J + DISKBYTES + 3), '00FFFFFC'B4), 24);


      PUT SKIP EDIT ( '*  FILE CONTROL BLOCK  ',
                     TRIM(DISKBYTES*(CODEMAX+1)),
                     TRIM(DISKBYTES*(DATAMAX*1)),
                     TRIM(CODEMAX+1),
                     TRIM(DATAMAX+1),
                     TRIM(DISKBYTES),
                     TRIM(JJ),
                     TRIM(IAND ((DP - J + DISKBYTES + 3), '00FFFFFC'B4))) (A, 7(A, X(4)));

/*      FILE(BINARYFILE,0) = CODE;   /* WRITE FIRST RECORD TO BINARY FILE */
      DO JJ = 0 TO DISKBYTES-1;       /* Rewrite the first record  of the code array. */
         CODE_ARRAY(JJ) = CODE(JJ);
      END;

      /* WRITE OUT THE CODE FILE TO BINARY FILE */
      DO I = 0 TO CODEMAX;
         DO JJ = 0 TO DISKBYTES-1;
            CODE(JJ) = CODE_ARRAY(I*3600 + JJ);
         END;
         WRITE FILE (BINARYFILE) FROM (CODE);
      END;

      BLOCKCNT = CODEMAX + 1;

/*      FILE(DATAFILE,CURDBLK) = DATA;  /* WRITE OUT CURRENT DATA ARRAY */
      DO JJ = 0 TO DISKBYTES-1;
         DATA_ARRAY(JJ + DISKBYTES*CURDBLK) = DATA(JJ);
      END;

      /*  WRITE OUT THE COMPILE DATA ARRAY  */

      DO J = 0 TO DATAMAX;
/*         DATA = FILE(DATAFILE,J); */
         DO JJ = 0 TO DISKBYTES-1;
            DATA(JJ) = DATA_ARRAY(JJ + DISKBYTES*J);
         END;
/*         FILE(BINARYFILE, BLOCKCNT)  =  DATA ; */
         WRITE FILE (BINARYFILE) FROM (DATA);
         BLOCKCNT = BLOCKCNT + 1;
      END;

      PUT SKIP LIST ( '*  LOAD FILE WRITTEN.' );

   END LOADER;


PRINT_SUMMARY:
   PROCEDURE;
      DECLARE I FIXED BINARY(7);

      CALL PRINT_DATE_AND_TIME ('END OF COMPILATION ', XPL_DATE(), XPL_TIME());
      PUT SKIP(2) EDIT ( TRIM(CARD_COUNT), ' CARDS CONTAINING ', TRIM(STATEMENT_COUNT),
          ' STATEMENTS WERE COMPILED.' ) (A);
      IF ERROR_COUNT = 0 THEN PUT SKIP LIST ( 'NO ERRORS WERE DETECTED.' );
      ELSE IF ERROR_COUNT > 1 THEN
         PUT SKIP EDIT ( ERROR_COUNT, ' ERRORS (', TRIM(SEVERE_ERRORS),
            ' SEVERE) WERE DETECTED.' )(A);
      ELSE IF SEVERE_ERRORS = 1 THEN PUT SKIP LIST ( 'ONE SEVERE ERROR WAS DETECTED.' );
         ELSE PUT SKIP LIST ('ONE ERROR WAS DETECTED.' );
      IF PREVIOUS_ERROR > 0 THEN
         PUT SKIP EDIT ( 'THE LAST DETECTED ERROR WAS ON LINE ', TRIM(PREVIOUS_ERROR),
            PERIOD) (A);
      PUT SKIP EDIT ( TRIM(PP), ' BYTES OF PROGRAM, ',
         TRIM(DP-DSP-CHP), ' OF DATA, ', TRIM(DSP), ' OF DESCRIPTORS, ',
         TRIM(CHP), ' OF STRINGS.  TOTAL CORE REQUIREMENT ',
         TRIM(PP + DP), ' bytes.' ) (A);
      IF CONTROL(BYTE('D')) THEN CALL DUMPIT;
      PUT SKIP(2);
      CLOCK(3) = XPL_TIME();
      DO I = 1 TO 3;   /* WATCH OUT FOR MIDNIGHT */
         IF CLOCK(I) < CLOCK(I-1) THEN CLOCK(I) = CLOCK(I) +  8640000;
      END;
      CALL PRINT_TIME ('TOTAL TIME IN COMPILER   ', CLOCK(3) - CLOCK(0));
      CALL PRINT_TIME ('SET UP TIME              ', CLOCK(1) - CLOCK(0));
      CALL PRINT_TIME ('ACTUAL COMPILATION TIME  ', CLOCK(2) - CLOCK(1));
      CALL PRINT_TIME ('POST-COMPILATION TIME    ', CLOCK(3) - CLOCK(2));
      IF CLOCK(2) > CLOCK(1) THEN   /* WATCH OUT FOR CLOCK BEING OFF */
         PUT SKIP EDIT ( 'COMPILATION RATE: ',
            TRIM(DIVIDE(6000*CARD_COUNT, (CLOCK(2)-CLOCK(1)), 31, 0)),
            ' CARDS PER MINUTE.' )(A);
   END PRINT_SUMMARY;

MAIN_PROCEDURE:
   PROCEDURE;
      CLOCK(0) = XPL_TIME();  /* KEEP TRACK OF TIME IN EXECUTION */
      CALL INITIALIZATION;

      /* CLOCK(1) GETS SET IN GETCARD */
      CALL COMPILATION_LOOP;

      CLOCK(2) = XPL_TIME();
      CALL LOADER;

      /* CLOCK(3) GETS SET IN PRINT_SUMMARY */
      CALL PRINT_SUMMARY;

   END MAIN_PROCEDURE;


CALL MAIN_PROCEDURE;
/* RETURN (SEVERE_ERRORS); */
  /* $Z */
END XPL_COMPILER;
